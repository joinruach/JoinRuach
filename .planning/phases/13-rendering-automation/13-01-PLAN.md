---
phase: 13-rendering-automation
plan: 01
type: execute
---

<objective>
Create render job model and state machine in Strapi for async video rendering workflow.

Purpose: Establish the foundational data model and API for operator-triggered video renders with proper state tracking, retry logic, and artifact management.

Output: Strapi content type, controller, routes, and state machine for render job orchestration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
**From Phase 12:**
- MultiCamComposition accepts props (sessionId, cameraSources, showCaptions, etc.)
- Remotion renders deterministically from EDL + transcripts
- Output is viewer-ready MP4 with captions and chapters

**From Phase 11:**
- Canonical EDL with approved/locked workflow
- EDL API: GET /api/recording-sessions/:id/edl

**From Phase 9:**
- Mezzanine URLs in assets (r2_video_prores_url)
- Camera sync offsets in session.syncOffsets_ms

**Phase 13 Decisions:**
- **Local-first rendering** (not cloud/Lambda yet)
- **Async job queue** (BullMQ/Redis)
- **Single profile** (1080p-h264-v1 to start)
- **State machine**: queued → preflight → rendering → uploading → complete/failed

**Victory Condition:**
Operator approves EDL → clicks Render → job completes → artifacts appear → download link works.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create render-job content type</name>
  <files>ruach-ministries-backend/src/api/render-job/content-types/render-job/schema.json</files>
  <action>Create Strapi content type for render job tracking:

  ```json
  {
    "kind": "collectionType",
    "collectionName": "render_jobs",
    "info": {
      "singularName": "render-job",
      "pluralName": "render-jobs",
      "displayName": "Render Job",
      "description": "Video render job tracking and state management"
    },
    "options": {
      "draftAndPublish": false,
      "comment": "Phase 13: Async video rendering workflow"
    },
    "attributes": {
      "jobId": {
        "type": "string",
        "required": true,
        "unique": true
      },
      "session": {
        "type": "relation",
        "relation": "manyToOne",
        "target": "api::recording-session.recording-session"
      },
      "edlVersion": {
        "type": "string",
        "required": false
      },
      "renderType": {
        "type": "enumeration",
        "enum": ["episode", "short", "clip"],
        "default": "episode",
        "required": true
      },
      "profile": {
        "type": "string",
        "default": "1080p-h264-v1",
        "required": true
      },
      "compositionId": {
        "type": "string",
        "default": "MultiCam",
        "required": true
      },
      "cameraSources": {
        "type": "json",
        "required": true
      },
      "props": {
        "type": "json",
        "required": false
      },
      "status": {
        "type": "enumeration",
        "enum": ["queued", "preflight", "rendering", "uploading", "complete", "failed", "canceled"],
        "default": "queued",
        "required": true
      },
      "progress": {
        "type": "integer",
        "min": 0,
        "max": 100,
        "default": 0
      },
      "attempts": {
        "type": "integer",
        "default": 0,
        "min": 0
      },
      "maxAttempts": {
        "type": "integer",
        "default": 3,
        "min": 1
      },
      "outputVideoUrl": {
        "type": "string",
        "required": false
      },
      "outputCaptionsUrl": {
        "type": "string",
        "required": false
      },
      "outputChaptersUrl": {
        "type": "string",
        "required": false
      },
      "thumbnailUrl": {
        "type": "string",
        "required": false
      },
      "artifacts": {
        "type": "json",
        "required": false
      },
      "errorCode": {
        "type": "string",
        "required": false
      },
      "errorMessage": {
        "type": "text",
        "required": false
      },
      "logs": {
        "type": "text",
        "required": false
      },
      "metrics": {
        "type": "json",
        "required": false
      }
    }
  }
  ```

  Field Design:
  - **Identity**: jobId (unique), session (relation), edlVersion
  - **Inputs**: cameraSources, props, compositionId, profile
  - **State**: status (enum), progress (0-100), attempts
  - **Outputs**: outputVideoUrl, artifacts (extensible)
  - **Observability**: errorCode, errorMessage, logs, metrics

  Generate Strapi API scaffold:
  ```bash
  cd ruach-ministries-backend
  pnpm strapi generate api render-job --no-cli
  ```

  Then edit schema.json with above structure.</action>
  <verify>Schema file exists, Strapi restarts without errors</verify>
  <done>Render job content type created with full state machine fields</done>
</task>

<task type="auto">
  <name>Task 2: Create state transition service</name>
  <files>ruach-ministries-backend/src/services/render-state-machine.ts</files>
  <action>Create state machine service for render job transitions:

  ```typescript
  /**
   * Phase 13: Render State Machine
   *
   * Single source of truth for render job state transitions
   */

  export type RenderStatus =
    | 'queued'
    | 'preflight'
    | 'rendering'
    | 'uploading'
    | 'complete'
    | 'failed'
    | 'canceled';

  export interface StateTransition {
    from: RenderStatus;
    to: RenderStatus;
    allowed: boolean;
    reason?: string;
  }

  export default class RenderStateMachine {
    /**
     * Valid state transitions
     */
    private static readonly TRANSITIONS: Record<RenderStatus, RenderStatus[]> = {
      queued: ['preflight', 'canceled'],
      preflight: ['rendering', 'failed', 'canceled'],
      rendering: ['uploading', 'failed', 'canceled'],
      uploading: ['complete', 'failed', 'canceled'],
      complete: [], // Terminal state
      failed: ['queued'], // Allow retry
      canceled: [], // Terminal state
    };

    /**
     * Check if a state transition is valid
     */
    static canTransition(from: RenderStatus, to: RenderStatus): StateTransition {
      const allowed = this.TRANSITIONS[from]?.includes(to) ?? false;

      if (!allowed) {
        return {
          from,
          to,
          allowed: false,
          reason: `Invalid transition: ${from} → ${to}`,
        };
      }

      return { from, to, allowed: true };
    }

    /**
     * Validate retry is allowed
     */
    static canRetry(status: RenderStatus, attempts: number, maxAttempts: number): boolean {
      // Only failed jobs can retry
      if (status !== 'failed') {
        return false;
      }

      // Check attempt limit
      return attempts < maxAttempts;
    }

    /**
     * Determine if status is terminal
     */
    static isTerminal(status: RenderStatus): boolean {
      return status === 'complete' || status === 'canceled';
    }

    /**
     * Determine if status is active
     */
    static isActive(status: RenderStatus): boolean {
      return ['queued', 'preflight', 'rendering', 'uploading'].includes(status);
    }

    /**
     * Get next expected status (for validation)
     */
    static getNextStatus(current: RenderStatus): RenderStatus | null {
      const transitions = this.TRANSITIONS[current];
      if (!transitions || transitions.length === 0) {
        return null;
      }

      // Return the "happy path" next status
      const happyPath: Record<RenderStatus, RenderStatus> = {
        queued: 'preflight',
        preflight: 'rendering',
        rendering: 'uploading',
        uploading: 'complete',
        complete: null,
        failed: 'queued', // Retry
        canceled: null,
      };

      return happyPath[current] ?? transitions[0];
    }
  }
  ```

  State Machine Rules:
  - **Happy path**: queued → preflight → rendering → uploading → complete
  - **Failure path**: Any active state can go to failed or canceled
  - **Retry path**: failed can go back to queued (if attempts < maxAttempts)
  - **Terminal states**: complete, canceled (no transitions out)

  Validation:
  - canTransition() enforces valid state changes
  - canRetry() checks attempt limits
  - isTerminal() and isActive() for status queries</action>
  <verify>TypeScript compiles, state machine logic is correct</verify>
  <done>State machine service with transition validation</done>
</task>

<task type="auto">
  <name>Task 3: Create render job service</name>
  <files>ruach-ministries-backend/src/api/render-job/services/render-job-service.ts</files>
  <action>Create Strapi service for render job operations:

  ```typescript
  import type { Core } from '@strapi/strapi';
  import { randomUUID } from 'crypto';
  import RenderStateMachine, { type RenderStatus } from '../../../services/render-state-machine';

  /**
   * Phase 13: Render Job Service
   *
   * Orchestrates render job lifecycle and state transitions
   */

  export interface CreateRenderJobInput {
    sessionId: string;
    renderType?: 'episode' | 'short' | 'clip';
    profile?: string;
    props?: Record<string, any>;
  }

  export default ({ strapi }: { strapi: Core.Strapi }) => ({
    /**
     * Create a new render job
     */
    async createJob(input: CreateRenderJobInput) {
      const { sessionId, renderType = 'episode', profile = '1080p-h264-v1', props = {} } = input;

      // Load session with assets
      const session = await strapi.entityService.findOne(
        'api::recording-session.recording-session',
        sessionId,
        {
          populate: ['assets', 'edl'],
        }
      ) as any;

      if (!session) {
        throw new Error(`Session ${sessionId} not found`);
      }

      // Validate EDL exists and is locked
      if (!session.edl) {
        throw new Error(`Session ${sessionId} has no EDL. Generate EDL first.`);
      }

      if (session.edl.status !== 'locked') {
        throw new Error(`EDL must be locked before rendering. Current status: ${session.edl.status}`);
      }

      // Resolve camera sources from assets
      const cameraSources: Record<string, string> = {};
      for (const asset of session.assets || []) {
        if (asset.angle && asset.r2_video_prores_url) {
          cameraSources[asset.angle] = asset.r2_video_prores_url;
        }
      }

      if (Object.keys(cameraSources).length === 0) {
        throw new Error(`Session ${sessionId} has no mezzanine URLs for rendering`);
      }

      // Generate unique job ID
      const jobId = `render-${randomUUID()}`;

      // Create render job
      const job = await strapi.entityService.create('api::render-job.render-job', {
        data: {
          jobId,
          session: sessionId,
          edlVersion: session.edl.version,
          renderType,
          profile,
          compositionId: 'MultiCam',
          cameraSources,
          props: {
            showCaptions: true,
            showChapters: true,
            showSpeakerLabels: true,
            debug: false,
            ...props,
          },
          status: 'queued',
          progress: 0,
          attempts: 0,
          maxAttempts: 3,
        },
      }) as any;

      strapi.log.info(`[render-job-service] Created job ${jobId} for session ${sessionId}`);

      return job;
    },

    /**
     * Transition job to new status
     */
    async transitionStatus(
      jobId: string,
      newStatus: RenderStatus,
      metadata?: {
        progress?: number;
        errorCode?: string;
        errorMessage?: string;
        logs?: string;
      }
    ) {
      // Find job
      const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
        filters: { jobId },
        limit: 1,
      }) as any[];

      if (!jobs || jobs.length === 0) {
        throw new Error(`Render job ${jobId} not found`);
      }

      const job = jobs[0];
      const currentStatus = job.status as RenderStatus;

      // Validate transition
      const transition = RenderStateMachine.canTransition(currentStatus, newStatus);
      if (!transition.allowed) {
        throw new Error(transition.reason || 'Invalid state transition');
      }

      // Update job
      const updated = await strapi.entityService.update(
        'api::render-job.render-job',
        job.id,
        {
          data: {
            status: newStatus,
            progress: metadata?.progress ?? job.progress,
            errorCode: metadata?.errorCode ?? job.errorCode,
            errorMessage: metadata?.errorMessage ?? job.errorMessage,
            logs: metadata?.logs ? `${job.logs || ''}\n${metadata.logs}` : job.logs,
          },
        }
      ) as any;

      strapi.log.info(
        `[render-job-service] Job ${jobId} transitioned: ${currentStatus} → ${newStatus}`
      );

      return updated;
    },

    /**
     * Mark job as complete with artifacts
     */
    async completeJob(
      jobId: string,
      artifacts: {
        outputVideoUrl: string;
        outputCaptionsUrl?: string;
        outputChaptersUrl?: string;
        thumbnailUrl?: string;
        metrics?: Record<string, any>;
      }
    ) {
      const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
        filters: { jobId },
        limit: 1,
      }) as any[];

      if (!jobs || jobs.length === 0) {
        throw new Error(`Render job ${jobId} not found`);
      }

      const job = jobs[0];

      // Validate transition to complete
      const transition = RenderStateMachine.canTransition(job.status, 'complete');
      if (!transition.allowed) {
        throw new Error(`Cannot complete job in status: ${job.status}`);
      }

      // Update with artifacts
      const updated = await strapi.entityService.update(
        'api::render-job.render-job',
        job.id,
        {
          data: {
            status: 'complete',
            progress: 100,
            outputVideoUrl: artifacts.outputVideoUrl,
            outputCaptionsUrl: artifacts.outputCaptionsUrl,
            outputChaptersUrl: artifacts.outputChaptersUrl,
            thumbnailUrl: artifacts.thumbnailUrl,
            artifacts: Object.entries(artifacts).map(([key, value]) => ({ key, value })),
            metrics: artifacts.metrics,
          },
        }
      ) as any;

      strapi.log.info(`[render-job-service] Job ${jobId} completed with artifacts`);

      return updated;
    },

    /**
     * Retry a failed job
     */
    async retryJob(jobId: string) {
      const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
        filters: { jobId },
        limit: 1,
      }) as any[];

      if (!jobs || jobs.length === 0) {
        throw new Error(`Render job ${jobId} not found`);
      }

      const job = jobs[0];

      // Validate retry is allowed
      if (!RenderStateMachine.canRetry(job.status, job.attempts, job.maxAttempts)) {
        throw new Error(
          `Cannot retry job ${jobId}: status=${job.status}, attempts=${job.attempts}/${job.maxAttempts}`
        );
      }

      // Reset to queued with incremented attempt counter
      const updated = await strapi.entityService.update(
        'api::render-job.render-job',
        job.id,
        {
          data: {
            status: 'queued',
            progress: 0,
            attempts: job.attempts + 1,
            errorCode: null,
            errorMessage: null,
          },
        }
      ) as any;

      strapi.log.info(
        `[render-job-service] Job ${jobId} retry attempt ${updated.attempts}/${updated.maxAttempts}`
      );

      return updated;
    },

    /**
     * Cancel a job
     */
    async cancelJob(jobId: string) {
      const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
        filters: { jobId },
        limit: 1,
      }) as any[];

      if (!jobs || jobs.length === 0) {
        throw new Error(`Render job ${jobId} not found`);
      }

      const job = jobs[0];

      // Can only cancel active jobs
      if (!RenderStateMachine.isActive(job.status)) {
        throw new Error(`Cannot cancel job in status: ${job.status}`);
      }

      const updated = await strapi.entityService.update(
        'api::render-job.render-job',
        job.id,
        {
          data: {
            status: 'canceled',
          },
        }
      ) as any;

      strapi.log.info(`[render-job-service] Job ${jobId} canceled`);

      return updated;
    },

    /**
     * Get job by ID
     */
    async getJob(jobId: string) {
      const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
        filters: { jobId },
        populate: ['session'],
        limit: 1,
      }) as any[];

      if (!jobs || jobs.length === 0) {
        throw new Error(`Render job ${jobId} not found`);
      }

      return jobs[0];
    },
  });
  ```

  Service Methods:
  - **createJob()**: Validate session → resolve camera sources → create job
  - **transitionStatus()**: Validate transition → update status + metadata
  - **completeJob()**: Store artifacts → mark complete
  - **retryJob()**: Validate retry allowed → reset to queued
  - **cancelJob()**: Validate active → mark canceled
  - **getJob()**: Fetch job with session relation

  Validation:
  - EDL must be locked before rendering
  - Camera sources must exist (mezzanine URLs)
  - State transitions validated via RenderStateMachine
  - Retry enforces attempt limits</action>
  <verify>TypeScript compiles, service methods complete</verify>
  <done>Render job service with full lifecycle management</done>
</task>

<task type="auto">
  <name>Task 4: Create render job controller</name>
  <files>ruach-ministries-backend/src/api/render-job/controllers/render-job-controller.ts</files>
  <action>Create REST API controller for render job operations:

  ```typescript
  import type { Core } from '@strapi/strapi';

  /**
   * Phase 13: Render Job Controller
   *
   * REST API endpoints for render job operations
   */

  export default ({ strapi }: { strapi: Core.Strapi }) => ({
    /**
     * POST /api/render-jobs/trigger
     * Create and queue a new render job
     */
    async trigger(ctx: any) {
      const { sessionId, renderType, profile, props } = ctx.request.body;

      if (!sessionId) {
        return ctx.badRequest('sessionId is required');
      }

      try {
        const renderJobService = strapi.service('api::render-job.render-job-service') as any;

        const job = await renderJobService.createJob({
          sessionId,
          renderType,
          profile,
          props,
        });

        ctx.body = {
          success: true,
          data: {
            jobId: job.jobId,
            status: job.status,
            sessionId: job.session?.id || sessionId,
          },
        };
      } catch (error) {
        strapi.log.error('[render-job-controller] Trigger failed:', error);
        ctx.badRequest(error instanceof Error ? error.message : 'Failed to trigger render job');
      }
    },

    /**
     * GET /api/render-jobs/:jobId
     * Get render job status and details
     */
    async get(ctx: any) {
      const { jobId } = ctx.params;

      if (!jobId) {
        return ctx.badRequest('jobId is required');
      }

      try {
        const renderJobService = strapi.service('api::render-job.render-job-service') as any;

        const job = await renderJobService.getJob(jobId);

        ctx.body = {
          success: true,
          data: {
            jobId: job.jobId,
            status: job.status,
            progress: job.progress,
            renderType: job.renderType,
            profile: job.profile,
            attempts: job.attempts,
            maxAttempts: job.maxAttempts,
            outputVideoUrl: job.outputVideoUrl,
            outputCaptionsUrl: job.outputCaptionsUrl,
            outputChaptersUrl: job.outputChaptersUrl,
            thumbnailUrl: job.thumbnailUrl,
            errorCode: job.errorCode,
            errorMessage: job.errorMessage,
            metrics: job.metrics,
            createdAt: job.createdAt,
            updatedAt: job.updatedAt,
          },
        };
      } catch (error) {
        strapi.log.error('[render-job-controller] Get failed:', error);
        ctx.notFound(error instanceof Error ? error.message : 'Render job not found');
      }
    },

    /**
     * POST /api/render-jobs/:jobId/retry
     * Retry a failed render job
     */
    async retry(ctx: any) {
      const { jobId } = ctx.params;

      if (!jobId) {
        return ctx.badRequest('jobId is required');
      }

      try {
        const renderJobService = strapi.service('api::render-job.render-job-service') as any;

        const job = await renderJobService.retryJob(jobId);

        ctx.body = {
          success: true,
          data: {
            jobId: job.jobId,
            status: job.status,
            attempts: job.attempts,
            maxAttempts: job.maxAttempts,
          },
        };
      } catch (error) {
        strapi.log.error('[render-job-controller] Retry failed:', error);
        ctx.badRequest(error instanceof Error ? error.message : 'Failed to retry render job');
      }
    },

    /**
     * POST /api/render-jobs/:jobId/cancel
     * Cancel an active render job
     */
    async cancel(ctx: any) {
      const { jobId } = ctx.params;

      if (!jobId) {
        return ctx.badRequest('jobId is required');
      }

      try {
        const renderJobService = strapi.service('api::render-job.render-job-service') as any;

        const job = await renderJobService.cancelJob(jobId);

        ctx.body = {
          success: true,
          data: {
            jobId: job.jobId,
            status: job.status,
          },
        };
      } catch (error) {
        strapi.log.error('[render-job-controller] Cancel failed:', error);
        ctx.badRequest(error instanceof Error ? error.message : 'Failed to cancel render job');
      }
    },
  });
  ```

  API Endpoints:
  - **POST /api/render-jobs/trigger** - Create new render job
  - **GET /api/render-jobs/:jobId** - Get job status
  - **POST /api/render-jobs/:jobId/retry** - Retry failed job
  - **POST /api/render-jobs/:jobId/cancel** - Cancel active job

  Response Format:
  ```json
  {
    "success": true,
    "data": { ... }
  }
  ```

  Error Handling:
  - Validate required parameters
  - Return appropriate HTTP status codes
  - Log errors with context
  - Consistent error messages</action>
  <verify>TypeScript compiles, controller methods complete</verify>
  <done>Render job REST API with 4 endpoints</done>
</task>

<task type="auto">
  <name>Task 5: Create render job routes</name>
  <files>ruach-ministries-backend/src/api/render-job/routes/render-job-routes.ts</files>
  <action>Create custom routes for render job API:

  ```typescript
  /**
   * Phase 13: Render Job Routes
   *
   * Custom routes for render job operations
   */

  export default {
    routes: [
      {
        method: 'POST',
        path: '/render-jobs/trigger',
        handler: 'render-job-controller.trigger',
        config: {
          policies: [],
          middlewares: [],
        },
      },
      {
        method: 'GET',
        path: '/render-jobs/:jobId',
        handler: 'render-job-controller.get',
        config: {
          policies: [],
          middlewares: [],
        },
      },
      {
        method: 'POST',
        path: '/render-jobs/:jobId/retry',
        handler: 'render-job-controller.retry',
        config: {
          policies: [],
          middlewares: [],
        },
      },
      {
        method: 'POST',
        path: '/render-jobs/:jobId/cancel',
        handler: 'render-job-controller.cancel',
        config: {
          policies: [],
          middlewares: [],
        },
      },
    ],
  };
  ```

  Route Configuration:
  - All routes under /api/render-jobs
  - Standard Strapi auth middleware applied
  - No additional policies for v1 (can add later)

  Routes:
  - POST /api/render-jobs/trigger
  - GET /api/render-jobs/:jobId
  - POST /api/render-jobs/:jobId/retry
  - POST /api/render-jobs/:jobId/cancel</action>
  <verify>Routes registered, endpoints accessible via Strapi</verify>
  <done>Render job routes configured</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Render job content type created in Strapi
- [ ] State machine service implements transition validation
- [ ] Render job service implements full lifecycle
- [ ] Controller implements 4 API endpoints
- [ ] Routes registered and accessible
- [ ] TypeScript compiles without errors
- [ ] Strapi restarts successfully
- [ ] API endpoints return expected responses (test with curl/Postman)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Render job can be created via POST /api/render-jobs/trigger
- Job status can be queried via GET /api/render-jobs/:jobId
- State machine enforces valid transitions
- Retry/cancel operations work correctly
- Ready for Plan 2 (worker implementation)
</success_criteria>

<output>
After completion, create `.planning/phases/13-rendering-automation/13-01-SUMMARY.md`:

# Phase 13 Plan 1: Render Job Model & State Machine Summary

**Async render job orchestration foundation**

## Accomplishments

- Created render-job content type with full state machine
- Built state transition validation service
- Implemented render job service with lifecycle management
- Created REST API with 4 endpoints (trigger, get, retry, cancel)
- Established data contracts for worker integration

## Next Step

Ready for Plan 2: Headless Remotion Runner (worker service + queue).
</output>
