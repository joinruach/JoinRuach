---
phase: 13-rendering-automation
plan: 02
type: execute
---

<objective>
Create worker service that processes render jobs via BullMQ queue with Remotion CLI execution.

Purpose: Build the actual rendering orchestration that consumes queued jobs, validates inputs, executes Remotion headlessly, and manages artifacts.

Output: Worker service with BullMQ queue, preflight validation, Remotion CLI wrapper, and retry logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
**From Phase 13 Plan 1:**
- Render job API with state machine (queued → processing → completed/failed)
- Service methods: transitionStatus(), completeJob(), failJob()
- Job structure: jobId, recordingSession, edl, format, status

**From Phase 12:**
- Remotion 4.0.415 in ruach-video-renderer package
- MultiCamComposition accepts: sessionId, cameraSources, showCaptions, showChapters
- Renders deterministically from EDL + transcripts
- Output: viewer-ready MP4 with captions and chapters

**Phase 13 Plan 2 Scope:**
- Local-first rendering (same infra as Strapi or sibling worker service)
- BullMQ queue (Redis-backed)
- Poll for queued jobs
- Preflight validation (EDL, sources, transcript deps)
- Remotion CLI wrapper
- Retry on transient failures only
- Upload artifacts to R2
- Mark complete or failed

**Victory Condition:**
Job queued → worker processes → video rendered → artifacts uploaded → job marked complete
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup BullMQ queue and worker infrastructure</name>
  <files>ruach-ministries-backend/package.json, ruach-ministries-backend/src/services/render-queue.ts</files>
  <action>Setup BullMQ for async job processing:

  Install BullMQ:
  ```bash
  cd ruach-ministries-backend
  pnpm add bullmq ioredis
  pnpm add -D @types/ioredis
  ```

  Create render queue service:
  ```typescript
  /**
   * Phase 13 Plan 2: Render Queue Service
   *
   * BullMQ queue for async render job processing
   */

  import { Queue } from 'bullmq';
  import Redis from 'ioredis';

  export interface RenderJobPayload {
    renderJobId: string;
    sessionId: string;
    format: string;
  }

  export default class RenderQueue {
    private static queue: Queue<RenderJobPayload> | null = null;
    private static connection: Redis | null = null;

    /**
     * Initialize queue connection
     */
    static async initialize() {
      if (this.queue) {
        return this.queue;
      }

      // Redis connection
      this.connection = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD,
        maxRetriesPerRequest: null, // Required for BullMQ
      });

      // Create queue
      this.queue = new Queue<RenderJobPayload>('render-jobs', {
        connection: this.connection,
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 5000, // 5s, 25s, 125s
          },
          removeOnComplete: {
            age: 24 * 3600, // Keep for 24 hours
            count: 100,
          },
          removeOnFail: {
            age: 7 * 24 * 3600, // Keep for 7 days
          },
        },
      });

      console.log('[render-queue] Initialized BullMQ queue');

      return this.queue;
    }

    /**
     * Add job to queue
     */
    static async addJob(payload: RenderJobPayload): Promise<string> {
      const queue = await this.initialize();

      const job = await queue.add('render-video', payload, {
        jobId: payload.renderJobId, // Use render job ID as BullMQ job ID
      });

      console.log(`[render-queue] Added job ${job.id} to queue`);

      return job.id!;
    }

    /**
     * Get queue instance
     */
    static async getQueue(): Promise<Queue<RenderJobPayload>> {
      return await this.initialize();
    }

    /**
     * Close queue connection
     */
    static async close() {
      if (this.queue) {
        await this.queue.close();
        this.queue = null;
      }
      if (this.connection) {
        await this.connection.quit();
        this.connection = null;
      }
    }
  }
  ```

  Queue Configuration:
  - Redis-backed job queue
  - 3 retry attempts with exponential backoff
  - Job cleanup: 24h for completed, 7 days for failed
  - Job ID matches renderJobId for tracking

  Environment Variables (.env):
  ```
  REDIS_HOST=localhost
  REDIS_PORT=6379
  REDIS_PASSWORD=
  ```
  </action>
  <verify>BullMQ installed, queue service compiles, Redis connection works</verify>
  <done>BullMQ queue infrastructure ready for job processing</done>
</task>

<task type="auto">
  <name>Task 2: Update render job service to enqueue jobs</name>
  <files>ruach-ministries-backend/src/api/render-job/services/render-job-service.ts</files>
  <action>Update createJob() to enqueue job in BullMQ after creation:

  Import RenderQueue at top:
  ```typescript
  import RenderQueue from '../../../services/render-queue';
  ```

  Update createJob() method to enqueue after creation:
  ```typescript
  // After job creation, before return

  // Enqueue job for processing
  try {
    const bullmqJobId = await RenderQueue.addJob({
      renderJobId: job.jobId,
      sessionId: sessionId,
      format: format,
    });

    // Update job with BullMQ job ID
    await strapi.entityService.update(
      'api::render-job.render-job',
      job.id,
      {
        data: {
          bullmq_job_id: bullmqJobId,
        } as any,
      }
    );

    strapi.log.info(
      `[render-job-service] Job ${job.jobId} enqueued as BullMQ job ${bullmqJobId}`
    );
  } catch (error) {
    strapi.log.error(
      `[render-job-service] Failed to enqueue job ${job.jobId}:`,
      error
    );
    // Don't throw - job still created, can be retried
  }
  ```

  Flow:
  1. Create render job in Strapi (status: queued)
  2. Add job to BullMQ queue
  3. Update render job with bullmq_job_id
  4. Worker will pick up job from queue
  </action>
  <verify>Jobs enqueued after creation, bullmq_job_id stored</verify>
  <done>Render jobs automatically enqueued for processing</done>
</task>

<task type="auto">
  <name>Task 3: Create preflight validator</name>
  <files>ruach-ministries-backend/src/services/render-preflight.ts</files>
  <action>Create preflight validation service:

  ```typescript
  /**
   * Phase 13 Plan 2: Render Preflight Validator
   *
   * Validates all prerequisites before starting render
   */

  import type { Core } from '@strapi/strapi';

  export interface PreflightResult {
    valid: boolean;
    errors: string[];
    warnings: string[];
  }

  export default class RenderPreflight {
    /**
     * Validate all prerequisites for rendering
     */
    static async validate(
      strapi: Core.Strapi,
      renderJobId: string
    ): Promise<PreflightResult> {
      const errors: string[] = [];
      const warnings: string[] = [];

      try {
        // Get render job
        const jobs = await strapi.entityService.findMany('api::render-job.render-job', {
          filters: { jobId: renderJobId },
          populate: ['recordingSession', 'edl'] as any,
          limit: 1,
        }) as any[];

        if (!jobs || jobs.length === 0) {
          errors.push(`Render job ${renderJobId} not found`);
          return { valid: false, errors, warnings };
        }

        const job = jobs[0];

        // Validate recording session
        if (!job.recordingSession) {
          errors.push('Recording session not found');
          return { valid: false, errors, warnings };
        }

        const session = job.recordingSession;

        // Validate EDL
        if (!job.edl) {
          errors.push('EDL not found');
        } else if (job.edl.status !== 'locked') {
          errors.push(`EDL status is ${job.edl.status}, must be locked`);
        }

        // Validate assets exist
        const assets = await strapi.entityService.findMany('api::asset.asset', {
          filters: {
            recordingSession: session.id,
          },
        }) as any[];

        if (!assets || assets.length === 0) {
          errors.push('No assets found for session');
        } else {
          // Validate mezzanine URLs exist
          const cameraSources: Record<string, string> = {};
          for (const asset of assets) {
            if (asset.angle && asset.r2_video_prores_url) {
              cameraSources[asset.angle] = asset.r2_video_prores_url;
            }
          }

          if (Object.keys(cameraSources).length === 0) {
            errors.push('No mezzanine URLs found in assets');
          }

          // Check for master camera
          const masterCamera = session.anchorAngle || 'A';
          if (!cameraSources[masterCamera]) {
            errors.push(`Master camera ${masterCamera} mezzanine URL not found`);
          }
        }

        // Validate sync offsets
        if (!session.syncOffsets_ms || Object.keys(session.syncOffsets_ms).length === 0) {
          errors.push('Sync offsets not found');
        }

        // Check for transcript (warning only if missing)
        const transcripts = await strapi.entityService.findMany(
          'api::library-transcription.library-transcription',
          {
            filters: {
              sourceMediaId: { $in: assets.map((a: any) => a.id) },
            },
            limit: 1,
          }
        ) as any[];

        if (!transcripts || transcripts.length === 0) {
          warnings.push('No transcript found - captions will not be rendered');
        }

        // Validate EDL canonical JSON exists
        if (job.edl && !job.edl.canonicalEdl) {
          errors.push('EDL canonical JSON not found');
        }

        return {
          valid: errors.length === 0,
          errors,
          warnings,
        };
      } catch (error) {
        errors.push(`Preflight validation error: ${error instanceof Error ? error.message : 'Unknown error'}`);
        return { valid: false, errors, warnings };
      }
    }
  }
  ```

  Validation Checks:
  - Render job exists
  - Recording session exists
  - EDL exists and is locked
  - Assets exist with mezzanine URLs
  - Master camera mezzanine available
  - Sync offsets present
  - Transcript available (warning if missing)
  - EDL canonical JSON exists

  Errors vs Warnings:
  - Errors: Block rendering (missing EDL, assets, etc.)
  - Warnings: Allow rendering (missing transcript means no captions)
  </action>
  <verify>Preflight validator compiles, catches missing prerequisites</verify>
  <done>Preflight validation prevents invalid render attempts</done>
</task>

<task type="auto">
  <name>Task 4: Create Remotion CLI wrapper</name>
  <files>ruach-ministries-backend/src/services/remotion-runner.ts</files>
  <action>Create service to execute Remotion renders:

  ```typescript
  /**
   * Phase 13 Plan 2: Remotion Runner
   *
   * Executes Remotion renders via CLI
   */

  import { exec } from 'child_process';
  import { promisify } from 'util';
  import * as path from 'path';
  import * as fs from 'fs/promises';

  const execAsync = promisify(exec);

  export interface RemotionRenderOptions {
    sessionId: string;
    cameraSources: Record<string, string>;
    outputPath: string;
    compositionId?: string;
    showCaptions?: boolean;
    showChapters?: boolean;
    showSpeakerLabels?: boolean;
    onProgress?: (progress: number) => void;
  }

  export interface RemotionRenderResult {
    success: boolean;
    outputPath?: string;
    durationMs?: number;
    error?: string;
    logs?: string;
  }

  export default class RemotionRunner {
    private static readonly RENDERER_DIR = path.join(
      process.cwd(),
      '..',
      'ruach-video-renderer'
    );

    /**
     * Render video using Remotion CLI
     */
    static async render(options: RemotionRenderOptions): Promise<RemotionRenderResult> {
      const {
        sessionId,
        cameraSources,
        outputPath,
        compositionId = 'MultiCam',
        showCaptions = true,
        showChapters = true,
        showSpeakerLabels = true,
      } = options;

      const startTime = Date.now();

      try {
        // Ensure output directory exists
        const outputDir = path.dirname(outputPath);
        await fs.mkdir(outputDir, { recursive: true });

        // Build Remotion props
        const props = {
          sessionId,
          cameraSources,
          showCaptions,
          showChapters,
          showSpeakerLabels,
          debug: false,
        };

        // Build Remotion CLI command
        const propsJson = JSON.stringify(props).replace(/"/g, '\\"');
        const command = `cd ${this.RENDERER_DIR} && pnpm remotion render ${compositionId} ${outputPath} --props="${propsJson}" --overwrite`;

        console.log('[remotion-runner] Executing render command');
        console.log(`[remotion-runner] Output: ${outputPath}`);

        // Execute render
        const { stdout, stderr } = await execAsync(command, {
          maxBuffer: 10 * 1024 * 1024, // 10MB buffer for logs
          timeout: 30 * 60 * 1000, // 30 minute timeout
        });

        const durationMs = Date.now() - startTime;

        console.log('[remotion-runner] Render completed');
        console.log(`[remotion-runner] Duration: ${durationMs}ms`);

        // Check if output file exists
        try {
          await fs.access(outputPath);
        } catch {
          return {
            success: false,
            error: 'Output file not created',
            logs: stdout + '\n' + stderr,
          };
        }

        return {
          success: true,
          outputPath,
          durationMs,
          logs: stdout,
        };
      } catch (error: any) {
        const durationMs = Date.now() - startTime;

        console.error('[remotion-runner] Render failed:', error);

        return {
          success: false,
          error: error.message || 'Unknown render error',
          durationMs,
          logs: error.stdout || error.stderr || '',
        };
      }
    }

    /**
     * Check if Remotion is installed and accessible
     */
    static async checkInstallation(): Promise<boolean> {
      try {
        const { stdout } = await execAsync(`cd ${this.RENDERER_DIR} && pnpm remotion --version`);
        console.log('[remotion-runner] Remotion version:', stdout.trim());
        return true;
      } catch (error) {
        console.error('[remotion-runner] Remotion not accessible:', error);
        return false;
      }
    }
  }
  ```

  Remotion CLI Execution:
  - Runs `pnpm remotion render` in ruach-video-renderer directory
  - Passes props as JSON to CLI
  - 30 minute timeout for long renders
  - Captures stdout/stderr for debugging
  - Verifies output file created

  Progress Tracking:
  - Currently basic (start/end only)
  - Future: Parse Remotion progress from stdout

  Error Handling:
  - Timeouts
  - Command failures
  - Missing output file
  - Logs captured for debugging
  </action>
  <verify>Remotion CLI wrapper compiles, can execute renders</verify>
  <done>Remotion render execution via CLI wrapper</done>
</task>

<task type="auto">
  <name>Task 5: Create render worker processor</name>
  <files>ruach-ministries-backend/src/services/render-worker.ts</files>
  <action>Create BullMQ worker to process render jobs:

  ```typescript
  /**
   * Phase 13 Plan 2: Render Worker
   *
   * BullMQ worker that processes render jobs
   */

  import { Worker, Job } from 'bullmq';
  import Redis from 'ioredis';
  import type { Core } from '@strapi/strapi';
  import type { RenderJobPayload } from './render-queue';
  import RenderPreflight from './render-preflight';
  import RemotionRunner from './remotion-runner';
  import * as path from 'path';
  import * as os from 'os';

  export default class RenderWorker {
    private static worker: Worker<RenderJobPayload> | null = null;
    private static connection: Redis | null = null;

    /**
     * Start worker
     */
    static async start(strapi: Core.Strapi) {
      if (this.worker) {
        console.log('[render-worker] Worker already running');
        return;
      }

      // Redis connection
      this.connection = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD,
        maxRetriesPerRequest: null,
      });

      // Create worker
      this.worker = new Worker<RenderJobPayload>(
        'render-jobs',
        async (job: Job<RenderJobPayload>) => {
          return await this.processJob(strapi, job);
        },
        {
          connection: this.connection,
          concurrency: 1, // Process one job at a time (CPU intensive)
        }
      );

      this.worker.on('completed', (job) => {
        console.log(`[render-worker] Job ${job.id} completed`);
      });

      this.worker.on('failed', (job, error) => {
        console.error(`[render-worker] Job ${job?.id} failed:`, error);
      });

      console.log('[render-worker] Worker started');
    }

    /**
     * Process a single render job
     */
    private static async processJob(
      strapi: Core.Strapi,
      job: Job<RenderJobPayload>
    ): Promise<void> {
      const { renderJobId, sessionId, format } = job.data;

      console.log(`[render-worker] Processing job ${renderJobId}`);

      const renderJobService = strapi.service('api::render-job.render-job-service') as any;

      try {
        // Move to processing
        await renderJobService.transitionStatus(renderJobId, 'processing', {
          progress: 0.1,
          bullmqJobId: job.id,
        });

        // Preflight validation
        console.log(`[render-worker] Running preflight checks for ${renderJobId}`);
        const preflight = await RenderPreflight.validate(strapi, renderJobId);

        if (!preflight.valid) {
          throw new Error(`Preflight failed: ${preflight.errors.join(', ')}`);
        }

        if (preflight.warnings.length > 0) {
          console.warn(`[render-worker] Warnings: ${preflight.warnings.join(', ')}`);
        }

        // Get job details
        const renderJob = await renderJobService.getJob(renderJobId);
        const session = renderJob.recordingSession;

        // Build camera sources
        const assets = await strapi.entityService.findMany('api::asset.asset', {
          filters: { recordingSession: session.id },
        }) as any[];

        const cameraSources: Record<string, string> = {};
        for (const asset of assets) {
          if (asset.angle && asset.r2_video_prores_url) {
            cameraSources[asset.angle] = asset.r2_video_prores_url;
          }
        }

        // Update progress
        await renderJobService.transitionStatus(renderJobId, 'processing', {
          progress: 0.2,
        });

        // Execute Remotion render
        console.log(`[render-worker] Starting Remotion render for ${renderJobId}`);

        const outputPath = path.join(
          os.tmpdir(),
          'ruach-renders',
          `${renderJobId}.mp4`
        );

        const renderResult = await RemotionRunner.render({
          sessionId,
          cameraSources,
          outputPath,
          showCaptions: true,
          showChapters: true,
          showSpeakerLabels: true,
          onProgress: async (progress) => {
            // Update progress (20% base + 70% for render + 10% for upload)
            await renderJobService.transitionStatus(renderJobId, 'processing', {
              progress: 0.2 + (progress * 0.7),
            });
          },
        });

        if (!renderResult.success) {
          throw new Error(renderResult.error || 'Render failed');
        }

        // Update progress
        await renderJobService.transitionStatus(renderJobId, 'processing', {
          progress: 0.9,
        });

        // TODO Plan 3: Upload to R2
        // For now, just mark complete with local path
        await renderJobService.completeJob(renderJobId, {
          outputVideoUrl: outputPath, // Will be R2 URL in Plan 3
          durationMs: renderResult.durationMs,
        });

        console.log(`[render-worker] Job ${renderJobId} completed successfully`);
      } catch (error: any) {
        console.error(`[render-worker] Job ${renderJobId} failed:`, error);

        await renderJobService.failJob(
          renderJobId,
          error.message || 'Unknown error during render'
        );

        throw error; // Re-throw for BullMQ retry logic
      }
    }

    /**
     * Stop worker
     */
    static async stop() {
      if (this.worker) {
        await this.worker.close();
        this.worker = null;
      }
      if (this.connection) {
        await this.connection.quit();
        this.connection = null;
      }
      console.log('[render-worker] Worker stopped');
    }
  }
  ```

  Worker Flow:
  1. Pick up job from queue
  2. Transition to 'processing'
  3. Run preflight validation
  4. Build camera sources from assets
  5. Execute Remotion render
  6. Update progress during render
  7. Mark complete or failed
  8. Re-throw errors for BullMQ retry

  Concurrency:
  - 1 job at a time (video rendering is CPU intensive)
  - Can be increased if multiple machines

  Error Handling:
  - Preflight failures: deterministic, no retry
  - Render failures: re-throw for BullMQ retry
  - Failed jobs marked in database
  </action>
  <verify>Worker compiles, can process jobs from queue</verify>
  <done>Complete render worker with preflight, Remotion exec, error handling</done>
</task>

<task type="auto">
  <name>Task 6: Add worker startup to Strapi bootstrap</name>
  <files>ruach-ministries-backend/src/index.ts</files>
  <action>Start render worker when Strapi starts:

  Check if src/index.ts exists and has bootstrap hook. If it exists, update it. If not, create it:

  ```typescript
  import RenderWorker from './services/render-worker';

  export default {
    /**
     * An asynchronous register function that runs before
     * your application is initialized.
     */
    register(/* { strapi } */) {},

    /**
     * An asynchronous bootstrap function that runs before
     * your application gets started.
     */
    async bootstrap({ strapi }) {
      // Start render worker
      if (process.env.ENABLE_RENDER_WORKER !== 'false') {
        try {
          await RenderWorker.start(strapi);
          console.log('[bootstrap] Render worker started');
        } catch (error) {
          console.error('[bootstrap] Failed to start render worker:', error);
        }
      }
    },

    /**
     * Called when Strapi is shutting down
     */
    async destroy() {
      await RenderWorker.stop();
      console.log('[destroy] Render worker stopped');
    },
  };
  ```

  Environment Variable:
  - ENABLE_RENDER_WORKER=true (default)
  - Set to 'false' to disable worker (useful for dev)

  Worker Lifecycle:
  - Starts on Strapi bootstrap
  - Stops on Strapi shutdown
  - Graceful shutdown handling
  </action>
  <verify>Worker starts with Strapi, can be disabled via env var</verify>
  <done>Worker integrated into Strapi lifecycle</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] BullMQ queue initialized and accessible
- [ ] Render jobs enqueued after creation
- [ ] Preflight validator catches missing prerequisites
- [ ] Remotion CLI wrapper executes renders
- [ ] Worker processes jobs from queue
- [ ] Worker starts with Strapi bootstrap
- [ ] TypeScript compiles without errors
- [ ] End-to-end test: trigger job → worker renders → job marked complete
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Job can be triggered via API
- Worker picks up and processes job
- Remotion render executes successfully
- Job transitions through states correctly
- Errors handled gracefully with retry logic
- Ready for Plan 3 (artifact upload to R2)
</success_criteria>

<output>
After completion, create `.planning/phases/13-rendering-automation/13-02-SUMMARY.md`:

# Phase 13 Plan 2: Headless Remotion Runner Summary

**Complete worker service with queue processing**

## Accomplishments

- Setup BullMQ queue with Redis backend
- Created preflight validator for render prerequisites
- Built Remotion CLI wrapper for headless rendering
- Implemented worker processor with full job lifecycle
- Integrated worker into Strapi bootstrap
- Complete end-to-end render orchestration

## Next Step

Ready for Plan 3: Artifact Management & R2 Upload.
</output>
