---
phase: 11-edl-generation
plan: 03
type: execute
---

<objective>
Create REST API endpoints and Strapi service wrapper for EDL generation and management.

Purpose: Expose EDL generation, retrieval, approval, and locking via REST API following Phase 9/10 patterns.

Output: Working API endpoints for compute, get, approve, and lock operations on EDLs.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/phases/11-edl-generation/11-02-SUMMARY.md
@ruach-ministries-backend/src/services/edl-generator.ts
@ruach-ministries-backend/src/api/recording-session/services/sync-service.ts
@ruach-ministries-backend/src/api/recording-session/services/transcript-service.ts
@ruach-ministries-backend/src/api/recording-session/controllers/sync-controller.ts
@ruach-ministries-backend/src/api/recording-session/routes/sync-routes.ts

**From Plan 2:**
- EDLGenerator.generateEDL() produces valid CanonicalEDL
- EDLValidator validates structure and timing
- CameraSwitcher, ChapterGenerator work correctly

**API Design Pattern (from Phase 9/10):**
- POST /recording-sessions/:id/edl/compute - Trigger EDL generation
- GET /recording-sessions/:id/edl - Get EDL JSON
- POST /recording-sessions/:id/edl/approve - Approve EDL for use
- POST /recording-sessions/:id/edl/lock - Lock EDL for rendering

**Workflow:**
1. Compute EDL (generates draft)
2. Operator reviews cuts and chapters
3. Approve EDL (marks as approved)
4. Lock EDL (ready for Phase 12 rendering, immutable)

**Don't hand-roll:**
- Follow sync-service.ts and transcript-service.ts patterns exactly
- Use same response format: { success: true, data: {...} }
- Use same error handling: ctx.badRequest(), ctx.notFound()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EDL Strapi service wrapper</name>
  <files>ruach-ministries-backend/src/api/recording-session/services/edl-service.ts</files>
  <action>Create Strapi service wrapper for EDL operations:

  Export functions:
  1. computeEDL(sessionId, options):
     - Load session with populate: ['assets', 'transcript', 'edl']
     - Check if EDL already exists and is locked (prevent regeneration)
     - Call EDLGenerator.generateEDL()
     - Create or update edit-decision-list entity
     - Store canonicalEdl JSON
     - Store audit data (generation timestamp, options, hashes)
     - Link to session via edl relation
     - Update session status to 'editing'
     - Return EDL metadata

  2. getEDL(sessionId):
     - Load session with populate: ['edl']
     - Return EDL data (status, version, canonicalEdl, metrics)
     - Throw if no EDL exists

  3. approveEDL(sessionId, approvedBy, notes):
     - Load session with populate: ['edl']
     - Update EDL status to 'approved'
     - Store approval metadata (approvedBy, approvedAt, notes)
     - Return updated EDL

  4. lockEDL(sessionId, lockedBy, notes):
     - Load session with populate: ['edl']
     - Verify EDL is approved (can't lock draft)
     - Update EDL status to 'locked'
     - Store lock metadata (lockedBy, lockedAt, notes)
     - Update session status to 'rendering' (ready for Phase 12)
     - Return updated EDL

  Storage structure:
  - canonicalEdl: Full CanonicalEDL JSON
  - version: Integer (increment on regeneration)
  - status: 'draft' | 'reviewing' | 'approved' | 'locked'
  - source: 'ai' (from generator)
  - audit: { generatedAt, options, transcriptHash, assetsHash }
  - metadata: { approvedBy, approvedAt, lockedBy, lockedAt, notes }

  Error handling:
  - Throw if prerequisites missing (sync, transcript)
  - Throw if trying to lock draft EDL
  - Throw if trying to regenerate locked EDL
  - Log all operations with session context

  Follow Phase 9 sync-service.ts pattern exactly.</action>
  <verify>TypeScript compiles, service exports all 4 functions</verify>
  <done>EDL service orchestrates generation and workflow management</done>
</task>

<task type="auto">
  <name>Task 2: Create EDL controller</name>
  <files>ruach-ministries-backend/src/api/recording-session/controllers/edl-controller.ts</files>
  <action>Create REST API controller for EDL endpoints:

  Export functions:
  1. compute(ctx): POST /:id/edl/compute
     - Extract sessionId from ctx.params.id
     - Extract options from ctx.request.body (style, includeChapters, etc.)
     - Call edl-service.computeEDL(sessionId, options)
     - Return { success: true, data: { sessionId, cutCount, chapterCount, ... } }

  2. get(ctx): GET /:id/edl
     - Extract sessionId from ctx.params.id
     - Call edl-service.getEDL(sessionId)
     - Return { success: true, data: { edlId, status, canonicalEdl, ... } }

  3. approve(ctx): POST /:id/edl/approve
     - Extract sessionId from ctx.params.id
     - Extract approvedBy, notes from ctx.request.body
     - Call edl-service.approveEDL(sessionId, approvedBy, notes)
     - Return { success: true, message: 'EDL approved', data: { ... } }

  4. lock(ctx): POST /:id/edl/lock
     - Extract sessionId from ctx.params.id
     - Extract lockedBy, notes from ctx.request.body
     - Call edl-service.lockEDL(sessionId, lockedBy, notes)
     - Return { success: true, message: 'EDL locked for rendering', data: { ... } }

  Error handling:
  - ctx.badRequest() for missing params or invalid input
  - ctx.notFound() for missing EDL
  - ctx.forbidden() for locked EDL operations
  - Log errors with session context

  Follow Phase 9 sync-controller.ts pattern exactly.</action>
  <verify>TypeScript compiles, controller exports 4 functions</verify>
  <done>EDL controller handles all API endpoints with proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create EDL routes</name>
  <files>ruach-ministries-backend/src/api/recording-session/routes/edl-routes.ts</files>
  <action>Create route definitions for EDL endpoints:

  Export default routes object:
  ```typescript
  export default {
    routes: [
      {
        method: 'POST',
        path: '/recording-sessions/:id/edl/compute',
        handler: 'edl-controller.compute',
        config: { policies: [], middlewares: [] }
      },
      {
        method: 'GET',
        path: '/recording-sessions/:id/edl',
        handler: 'edl-controller.get',
        config: { policies: [], middlewares: [] }
      },
      {
        method: 'POST',
        path: '/recording-sessions/:id/edl/approve',
        handler: 'edl-controller.approve',
        config: { policies: [], middlewares: [] }
      },
      {
        method: 'POST',
        path: '/recording-sessions/:id/edl/lock',
        handler: 'edl-controller.lock',
        config: { policies: [], middlewares: [] }
      }
    ]
  };
  ```

  Follow Phase 9 sync-routes.ts pattern exactly.</action>
  <verify>TypeScript compiles, routes export correctly</verify>
  <done>EDL routes registered and accessible via API</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] edl-service.ts exports 4 functions
- [ ] edl-controller.ts exports 4 handlers
- [ ] edl-routes.ts registers 4 routes
- [ ] pnpm run build succeeds
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- EDL service orchestrates generation and workflow
- API endpoints follow Phase 9/10 patterns
- Workflow: compute → get → approve → lock
- Ready for Phase 12 (Remotion rendering)
</success_criteria>

<output>
After completion, create `.planning/phases/11-edl-generation/11-03-SUMMARY.md`:

# Phase 11 Plan 3: REST API & Strapi Integration Summary

**Complete EDL workflow with REST API**

## Accomplishments

- Created EDL Strapi service wrapper orchestrating workflow
- Implemented REST API controller with 4 endpoints
- Registered routes following Phase 9/10 patterns
- Workflow: compute → get → approve → lock
- Integrated with edit-decision-list content type

## Files Created/Modified

- `ruach-ministries-backend/src/api/recording-session/services/edl-service.ts` - Strapi service wrapper
- `ruach-ministries-backend/src/api/recording-session/controllers/edl-controller.ts` - REST API controller
- `ruach-ministries-backend/src/api/recording-session/routes/edl-routes.ts` - Route definitions

## Next Step

Phase 11 complete! Ready for Phase 12 (Remotion rendering) and Phase 13 (Studio UI).
</output>
