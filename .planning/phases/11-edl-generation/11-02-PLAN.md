---
phase: 11-edl-generation
plan: 02
type: execute
---

<objective>
Implement EDL Generator Engine with rules-based camera switching and AI chapter generation.

Purpose: Generate time-accurate multi-camera edit plans from aligned transcripts using intelligent camera switching rules, timing constraints, and AI-powered chapter titles.

Output: Working EDL generator service that produces valid Canonical EDL JSON ready for operator review.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/phases/11-edl-generation/11-01-SUMMARY.md
@ruach-ministries-backend/src/types/canonical-edl.ts
@ruach-ministries-backend/src/api/recording-session/services/transcript-service.ts
@ruach-ministries-backend/src/services/transcription-service.ts

**From Plan 1:**
- Canonical EDL TypeScript interfaces defined
- edit-decision-list content type ready for storage
- Recording session linked to EDL via relation

**Inputs Available:**
- Aligned transcripts per camera (Phase 10): speaker labels, word timestamps, confidence
- Sync offsets (Phase 9): camera timing adjustments
- Session metadata: duration, master camera, asset URLs

**Generator Requirements:**
1. Rules-based camera switching (speaker-aware, deterministic)
2. Timing constraints: min 2s, max 15s shot length, 1.5s cooldown
3. AI chapter generation from transcript segments
4. Confidence scoring for review
5. EDL validation (no gaps, no overlaps, valid cameras)

**Don't hand-roll:**
- Use existing transcript data structures from Phase 10
- Use Anthropic SDK for AI chapter generation
- Use crypto.randomUUID() for cut IDs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EDL validator utility</name>
  <files>ruach-ministries-backend/src/services/edl-validator.ts</files>
  <action>Create validation service for Canonical EDL:

  Export function:
  ```typescript
  validateEDL(edl: CanonicalEDL): EDLValidationResult
  ```

  Validation rules:
  1. Schema version check (must be "1.0")
  2. Program track required and non-empty
  3. All cuts have valid cameras (A, B, or C)
  4. Cuts are non-overlapping and sequential
  5. No gaps between cuts (unless intentional trim)
  6. Cut times are within session duration
  7. Min shot length >= 2000ms (configurable)
  8. All cut IDs are unique
  9. Sources contain all referenced cameras
  10. Camera offsets are numbers

  Return:
  - valid: boolean
  - errors: string[] (fatal issues)
  - warnings: string[] (non-fatal suggestions)

  Example warnings:
  - "Shot at 120000ms is very long (25000ms)"
  - "High frequency switching detected (5 cuts in 10s)"
  - "Camera B never used"

  Keep validation strict but informative.</action>
  <verify>TypeScript compiles, exports validateEDL function</verify>
  <done>EDL validator can catch timing errors, overlaps, and invalid structure</done>
</task>

<task type="auto">
  <name>Task 2: Create camera switching rules engine</name>
  <files>ruach-ministries-backend/src/services/camera-switcher.ts</files>
  <action>Create rules-based camera selection service:

  Core algorithm:
  1. Default camera logic:
     - Single speaker → prefer close-up (A or B based on speaker ID)
     - Multiple speakers → wide shot (C) or reaction shots
     - No speaker (silence) → hold current camera

  2. Speaker-to-camera mapping (simple v1):
     - Speaker A → Camera A
     - Speaker B → Camera B
     - Unknown speaker → Camera C (wide)
     - Multiple speakers → Camera C (wide)

  3. Timing constraints:
     - minShotLengthMs: 2000 (avoid jarring cuts)
     - maxShotLengthMs: 15000 (maintain energy)
     - switchCooldownMs: 1500 (prevent rapid switching)

  4. Shot boundary detection:
     - Switch on speaker change (if > minShotLength elapsed)
     - Switch if current shot > maxShotLength
     - Respect cooldown (don't switch again within 1.5s)

  Export function:
  ```typescript
  generateCuts(
    alignedTranscripts: Record<string, TranscriptSegment[]>,
    sessionId: string,
    masterCamera: string,
    durationMs: number,
    options?: Partial<EDLGenerationOptions>
  ): Cut[]
  ```

  Implementation notes:
  - Process transcript chronologically
  - Track lastSwitchTime to enforce cooldown
  - Assign reason field: "speaker" | "wide" | "emphasis"
  - Generate unique IDs: crypto.randomUUID()
  - Calculate confidence based on transcript confidence + boundary clarity

  Keep it simple and deterministic (no randomness).</action>
  <verify>TypeScript compiles, exports generateCuts function</verify>
  <done>Camera switcher produces valid cuts with timing constraints</done>
</task>

<task type="auto">
  <name>Task 3: Create chapter generator with AI</name>
  <files>ruach-ministries-backend/src/services/chapter-generator.ts</files>
  <action>Create AI-powered chapter title generation:

  Use Anthropic SDK to generate chapter titles from transcript segments.

  Export function:
  ```typescript
  async generateChapters(
    transcriptSegments: TranscriptSegment[],
    sessionId: string
  ): Promise<Chapter[]>
  ```

  Algorithm:
  1. Group transcript into logical sections:
     - Every 5-10 minutes or on major topic shifts
     - Use speaker changes + silence gaps as hints

  2. Call Anthropic API for each section:
     - Provide transcript text
     - Ask for concise chapter title (3-5 words)
     - Examples: "Opening Prayer", "Main Teaching", "Closing Remarks"

  3. Generate Chapter objects:
     - startMs: section start time
     - title: AI-generated title

  Prompt template:
  ```
  Generate a concise chapter title (3-5 words) for this section of a sermon/teaching:

  Transcript:
  {transcript_text}

  Respond with only the chapter title, no explanation.
  ```

  Use environment variable: ANTHROPIC_API_KEY
  Model: claude-3-haiku-20240307 (fast + cheap for this task)

  Graceful degradation: If API fails, return generic titles ("Section 1", "Section 2", etc.)</action>
  <verify>TypeScript compiles, exports generateChapters function</verify>
  <done>Chapter generator creates meaningful section titles using AI</done>
</task>

<task type="auto">
  <name>Task 4: Create EDL generator service</name>
  <files>ruach-ministries-backend/src/services/edl-generator.ts</files>
  <action>Create main EDL generator orchestrating all components:

  Export class:
  ```typescript
  export default class EDLGenerator {
    async generateEDL(
      sessionId: string,
      strapi: Core.Strapi,
      options?: Partial<EDLGenerationOptions>
    ): Promise<CanonicalEDL>
  }
  ```

  Pipeline:
  1. Load session with populate: ['assets', 'transcript']
  2. Validate prerequisites:
     - Session has syncOffsets_ms
     - Session has transcript with aligned segments
     - All cameras have assets

  3. Extract data:
     - alignedTranscripts from transcript.metadata.masterTranscript
     - syncOffsets from session.syncOffsets_ms
     - Camera sources (assetId, URLs, offsets)

  4. Generate program track:
     - Call camera-switcher.generateCuts()
     - Apply options (minShotLength, maxShotLength, cooldown)

  5. Generate chapters (if includeChapters):
     - Call chapter-generator.generateChapters()

  6. Build CameraSource objects:
     - Map assets to sources with Phase 9 offsets
     - Include proxyUrl and mezzanineUrl

  7. Calculate metrics:
     - cutCount: tracks.program.length
     - avgShotLenMs: average of (cut.endMs - cut.startMs)
     - speakerSwitchCount: count cuts with reason="speaker"
     - confidence: weighted average of cut confidences

  8. Construct CanonicalEDL object:
     - schemaVersion: "1.0"
     - All fields populated

  9. Validate EDL:
     - Call edl-validator.validateEDL()
     - Log warnings, throw on errors

  10. Return CanonicalEDL

  Error handling:
  - Throw descriptive errors if prerequisites missing
  - Log all validation warnings
  - Gracefully handle AI failures (skip chapters)

  Follow Phase 10 transcription-service.ts pattern for consistency.</action>
  <verify>TypeScript compiles, exports EDLGenerator class</verify>
  <done>EDL generator orchestrates full pipeline and produces valid CanonicalEDL</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] edl-validator.ts exports validateEDL
- [ ] camera-switcher.ts exports generateCuts
- [ ] chapter-generator.ts exports generateChapters
- [ ] edl-generator.ts exports EDLGenerator class
- [ ] pnpm run build succeeds
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- EDL generator produces valid Canonical EDL JSON
- Camera switching follows timing constraints
- Chapters generated with AI (with graceful fallback)
- EDL validation catches errors before storage
- Ready for Phase 11 Plan 3 (REST API + Strapi integration)
</success_criteria>

<output>
After completion, create `.planning/phases/11-edl-generation/11-02-SUMMARY.md`:

# Phase 11 Plan 2: EDL Generator Engine Summary

**Rules-based camera switching and AI chapter generation**

## Accomplishments

- Created EDL validator for structural and timing validation
- Implemented rules-based camera switcher with timing constraints
- Added AI-powered chapter title generation
- Built EDL generator orchestrating full pipeline
- Integrated with Phase 9 sync and Phase 10 transcript data

## Files Created/Modified

- `ruach-ministries-backend/src/services/edl-validator.ts` - EDL validation
- `ruach-ministries-backend/src/services/camera-switcher.ts` - Camera switching rules
- `ruach-ministries-backend/src/services/chapter-generator.ts` - AI chapter titles
- `ruach-ministries-backend/src/services/edl-generator.ts` - Main generator orchestration

## Decisions Made

- Rules-first approach for camera switching (deterministic, debuggable)
- Speaker-to-camera mapping: Speaker A → Camera A, Speaker B → Camera B, wide → Camera C
- Timing constraints: 2s min, 15s max, 1.5s cooldown
- AI only for chapters (Haiku model for speed/cost)
- Graceful degradation if AI fails

## Next Step

Ready for 11-03-PLAN.md: REST API endpoints and Strapi service wrapper
</output>
