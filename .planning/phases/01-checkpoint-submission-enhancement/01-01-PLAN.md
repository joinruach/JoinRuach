---
phase: 01-checkpoint-submission-enhancement
plan: 01
type: execute
---

<objective>
Complete the checkpoint submission flow with word count tracking, enhanced dwell timer UI, and validation enforcement to ensure reflections meet formation requirements before submission.

Purpose: Enforce genuine engagement with formation content by requiring minimum word count (50 words) and dwell time (varies by checkpoint) before allowing submission. This prevents checkbox completion and encourages deeper reflection.

Output: Enhanced checkpoint form with live validation feedback, disabled submit button until requirements met, and draft persistence for recovery.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Existing Code:**
@apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx
@apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts

**Codebase Context:**
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

**Current Implementation:**
The SectionView.tsx component already has:
- Basic dwell timer (starts on mount, hidden field in form)
- Minimum dwell time check (shows checkpoint after wait)
- Textarea for reflection input
- Server action submission (submitCheckpoint in actions.ts)

**What's Missing:**
- Word count tracker with live display
- 50-word minimum validation (client AND server)
- Submit button disabled until both requirements met
- Visual progress indicators for dwell time and word count
- Draft persistence to localStorage with proper keying
- Clear validation error messages
- Tab visibility handling for dwell timer
- Server-side enforcement of formation gate requirements

**Requirements from PROJECT.md:**
- Word count tracker (minimum 50 words enforced)
- Dwell timer (varies by checkpoint, enforced client + server)
- Submit button disabled until requirements met
- Clean validation messages

**Formation Gate Integrity:**
This phase establishes the validation layer that all subsequent phases depend on. Both client-side (UX) and server-side (security) enforcement are required to prevent loopholes. The word count algorithm must be deterministic and match exactly between client and server.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add word count validation (client + server)</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx, apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts</files>
  <action>
Add deterministic word count validation on both client (UX) and server (security):

**DETERMINISTIC WORD COUNT ALGORITHM** (use exactly this on both client and server):
```typescript
function countWords(text: string): number {
  // Normalize: trim leading/trailing whitespace
  const normalized = text.trim();

  // Handle empty string
  if (normalized.length === 0) return 0;

  // Split on any whitespace (space, tab, newline)
  const tokens = normalized.split(/\s+/);

  // Filter out empty tokens and punctuation-only tokens
  // Unicode-safe: matches letters (including Hebrew/Greek) and numbers, not just ASCII
  const HAS_WORD = /[\p{L}\p{N}]/u;
  const words = tokens.filter(token => {
    return token.length > 0 && HAS_WORD.test(token);
  });

  return words.length;
}
```

**WHY Unicode-safe:** `/\w/` only matches ASCII word characters (a-zA-Z0-9_) and treats underscore as a word. `[\p{L}\p{N}]` matches all Unicode letters and numbers (Hebrew, Greek, accents, etc.) and ignores pure punctuation like "—".

**CLIENT-SIDE (SectionView.tsx):**

1. Add the canonical countWords function at top of component (outside component function for clarity)

2. Add state for reflection text and word count:
   ```typescript
   const [reflection, setReflection] = useState("");
   const [wordCount, setWordCount] = useState(0);
   ```

3. Handle textarea changes:
   ```typescript
   const handleReflectionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
     const text = e.target.value;
     setReflection(text);
     setWordCount(countWords(text));
   };
   ```

4. Add word count display showing REMAINING words (better UX):
   ```typescript
   <div className="flex items-center justify-between mt-2 text-sm">
     <span className={wordCount >= 50 ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       {wordCount} / 50 words {wordCount >= 50 ? "✓" : ""}
     </span>
     {wordCount < 50 && (
       <span className="text-amber-600 dark:text-amber-400">
         {50 - wordCount} remaining
       </span>
     )}
   </div>
   ```

5. Update textarea to controlled component:
   ```typescript
   <textarea
     value={reflection}
     onChange={handleReflectionChange}
     // ... existing props
   />
   ```

**SERVER-SIDE (actions.ts):**

1. Add the SAME canonical countWords function to actions.ts (duplicate is intentional for security)

2. In submitCheckpoint server action, BEFORE processing the reflection:
   ```typescript
   // Validate word count (server-side enforcement - hard gate)
   const wordCount = countWords(formData.get('reflection') as string);
   if (wordCount < 50) {
     return {
       ok: false,
       message: `Reflection must be at least 50 words (you submitted ${wordCount} words).`
     };
   }
   ```

**NOTE:** Dwell time validation happens in Task 2 via heartbeat tracking (server maintains visible time accumulation).

**WHY DUPLICATE THE FUNCTION:** Server-side validation cannot be bypassed by modifying client code or POSTing directly. Client and server must use identical logic to avoid mismatch errors.

**WHY NOT validate dwell time here:** Client-sent `dwellTimeSeconds` can be spoofed. True dwell enforcement requires server-side time tracking via heartbeat (implemented in Task 2).
  </action>
  <verify>
CLIENT-SIDE:
1. Navigate to any guidebook section
2. Type in textarea and verify word count updates live
3. Verify "X remaining" shows correctly (e.g., "12 / 50 words (38 remaining)")
4. Type exactly 50 words - verify checkmark appears
5. Verify color changes neutral → green at 50+ words
6. Test Unicode: type Hebrew/Greek characters, verify they count as words
7. Test punctuation: type "—" or "..." alone, verify it doesn't count

SERVER-SIDE:
8. Open browser DevTools Network tab
9. Type 30 words, wait for dwell time, submit
10. Verify server returns error: "Reflection must be at least 50 words (you submitted 30 words)"
11. Type 50+ words, submit - verify success
12. Test direct POST with curl (bypassing UI) - verify server rejects <50 words:
    ```bash
    curl -X POST /api/checkpoints/submit \
      -d "reflection=short text"
    ```
  </verify>
  <done>
- Identical countWords function exists in both SectionView.tsx and actions.ts
- Unicode-safe regex `[\p{L}\p{N}]` counts Hebrew/Greek/accents correctly
- Client-side word count updates in real-time with "X remaining" display
- Server-side validation rejects submissions < 50 words with clear error message
- Color feedback and checkmark work correctly
- Server cannot be bypassed by direct POST or modified client code (word count only - dwell in Task 2)
  </done>
</task>

<task type="auto">
  <name>Task 2: Server-tracked dwell time with heartbeat and tab visibility</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx, apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts</files>
  <action>
Implement true server-side dwell tracking via heartbeat pings. Cannot be bypassed.

**POLICY DECISION:** Dwell time counts only while tab is VISIBLE and is tracked by the server via heartbeat pings every 10 seconds. Client-sent dwell time cannot be trusted.

**ARCHITECTURE:**
- Client sends heartbeat ping every 10s while tab is visible
- Server accumulates `visibleSeconds += 10` per ping
- On submit, server validates `accumulatedSeconds >= checkpoint.minimumDwellSeconds`
- Client timer is UX-only (shows progress), server time is truth

**SERVER-SIDE (actions.ts):**

1. Create new server action for heartbeat tracking (delta-based, replay-safe):
   ```typescript
   export async function trackDwellHeartbeat(formData: FormData) {
     const sectionId = formData.get('sectionId') as string;
     const checkpointId = formData.get('checkpointId') as string;
     const userId = formData.get('userId') as string; // or anonymousUserId
     const attemptId = formData.get('attemptId') as string; // Session-scoped ID
     const heartbeatSeq = parseInt(formData.get('heartbeatSeq') as string); // Monotonic sequence

     // Rate limit: 1 heartbeat per 8-12 seconds per attempt
     // If too frequent, return last known state (don't error - graceful degradation)
     const rateLimitKey = `ratelimit:heartbeat:${attemptId}`;
     const lastPing = await redis.get(rateLimitKey);
     if (lastPing && (Date.now() - parseInt(lastPing)) < 8000) {
       const session = await getDwellSession(attemptId);
       return { ok: true, accumulatedSeconds: session?.accumulatedSeconds || 0, rateLimited: true };
     }
     await redis.set(rateLimitKey, Date.now().toString(), 'EX', 12);

     // Get or create dwell session (scoped by attemptId, not userId+checkpointId)
     const session = await getOrCreateDwellSession(attemptId, {
       userId,
       sectionId,
       checkpointId,
       startedAt: Date.now()
     });

     // Idempotency: check heartbeat sequence
     if (heartbeatSeq <= session.lastHeartbeatSeq) {
       // Duplicate or old heartbeat - ignore, return current state
       return { ok: true, accumulatedSeconds: session.accumulatedSeconds, duplicate: true };
     }

     // Delta-based accumulation (not fixed +10)
     const now = Date.now();
     const delta = session.lastHeartbeatAt
       ? Math.floor((now - session.lastHeartbeatAt) / 1000)
       : 0;

     // Clamp delta: 0 <= delta <= 15 (heartbeat interval is 10s, allow 5s grace for jitter)
     const clampedDelta = Math.max(0, Math.min(delta, 15));

     // Accumulate clamped delta
     session.accumulatedSeconds += clampedDelta;
     session.lastHeartbeatAt = now;
     session.lastHeartbeatSeq = heartbeatSeq;

     // Save with TTL refresh (1 hour, extends on each ping)
     await saveDwellSession(attemptId, session, 3600); // TTL 3600s

     return { ok: true, accumulatedSeconds: session.accumulatedSeconds };
   }
   ```

2. Update submitCheckpoint to validate accumulated dwell time:
   ```typescript
   // In submitCheckpoint, BEFORE processing reflection:
   const attemptId = formData.get('attemptId') as string;

   // Get accumulated dwell time from server session (by attemptId)
   const session = await getDwellSession(attemptId);

   if (!session || session.accumulatedSeconds < checkpoint.minimumDwellSeconds) {
     return {
       ok: false,
       message: `Please spend at least ${checkpoint.minimumDwellSeconds} seconds engaging with the content. (You've accumulated ${session?.accumulatedSeconds || 0} seconds.)`
     };
   }

   // Validate attemptId matches session metadata (prevent attempt swapping)
   if (session.checkpointId !== checkpoint.id) {
     return {
       ok: false,
       message: 'Invalid dwell session. Please reload and try again.'
     };
   }

   // After successful submission, clear dwell session
   await clearDwellSession(attemptId);
   ```

**REDIS SCHEMA:**
```typescript
// Key: `dwell:attempt:{attemptId}`
// Value (JSON):
{
  userId: string;
  sectionId: string;
  checkpointId: string;
  accumulatedSeconds: number;
  lastHeartbeatAt: number; // timestamp (ms)
  lastHeartbeatSeq: number; // monotonic sequence
  startedAt: number; // timestamp (ms)
}
// TTL: 3600s (1 hour), refreshed on each heartbeat
```

**ANTI-GAMING PROTECTIONS:**
- Delta-based (not fixed +10): prevents replay attacks inflating time
- Clamped 0-15s: prevents network jitter or malicious deltas
- Sequence tracking: ignores duplicate/old heartbeats
- attemptId scoping: time tied to "this reading session", not "this user + checkpoint"
- Rate limiting: 1 ping per 8-12s, graceful degradation on violation
- TTL refresh: extends session life on each valid heartbeat

**CLIENT-SIDE (SectionView.tsx):**

1. Generate attemptId and initialize state on mount:
   ```typescript
   // Generate unique attemptId for this reading session
   const [attemptId] = useState(() => {
     return `attempt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
   });

   const [heartbeatSeq, setHeartbeatSeq] = useState(0);
   const [serverAccumulatedSeconds, setServerAccumulatedSeconds] = useState(0);
   const [lastVisibleAt, setLastVisibleAt] = useState<number | null>(null);
   const [isTabVisible, setIsTabVisible] = useState(true);
   ```

2. Track tab visibility with timestamp-based accumulation (avoids drift):
   ```typescript
   useEffect(() => {
     const handleVisibilityChange = () => {
       setIsTabVisible(document.visibilityState === 'visible');
     };

     const handlePageHide = () => {
       // Safari/iOS: ensure cleanup on page hide
       setIsTabVisible(false);
       setLastVisibleAt(null);
     };

     document.addEventListener('visibilitychange', handleVisibilityChange);
     window.addEventListener('pagehide', handlePageHide);
     window.addEventListener('beforeunload', handlePageHide);

     // Initialize on mount
     if (document.visibilityState === 'visible') {
       setLastVisibleAt(performance.now());
     }

     return () => {
       document.removeEventListener('visibilitychange', handleVisibilityChange);
       window.removeEventListener('pagehide', handlePageHide);
       window.removeEventListener('beforeunload', handlePageHide);
     };
   }, []);
   ```

3. Update display time every second (optimistic + server reconciliation):
   ```typescript
   const [displaySeconds, setDisplaySeconds] = useState(0);

   useEffect(() => {
     const interval = setInterval(() => {
       if (isTabVisible && lastVisibleAt !== null) {
         // Optimistic: show local elapsed time since last visible
         const localElapsed = Math.floor((performance.now() - lastVisibleAt) / 1000);
         setDisplaySeconds(serverAccumulatedSeconds + localElapsed);
       } else {
         // Hidden: show server truth
         setDisplaySeconds(serverAccumulatedSeconds);
       }
     }, 1000);

     return () => clearInterval(interval);
   }, [isTabVisible, lastVisibleAt, serverAccumulatedSeconds]);
   ```

4. Send heartbeat ping every 10 seconds with sequence and attemptId:
   ```typescript
   useEffect(() => {
     if (!isTabVisible) return;

     const heartbeatInterval = setInterval(async () => {
       if (isTabVisible) {
         // Increment sequence (monotonic)
         const seq = heartbeatSeq + 1;
         setHeartbeatSeq(seq);

         const formData = new FormData();
         formData.append('sectionId', section.id);
         formData.append('checkpointId', checkpoint.id);
         formData.append('userId', userId); // from session or anonymous ID
         formData.append('attemptId', attemptId);
         formData.append('heartbeatSeq', seq.toString());

         const response = await trackDwellHeartbeat(formData);

         // Reconcile with server truth
         if (response.ok) {
           setServerAccumulatedSeconds(response.accumulatedSeconds);
           // Reset local tracking baseline
           setLastVisibleAt(performance.now());
         }
       }
     }, 10000); // 10 seconds

     return () => clearInterval(heartbeatInterval);
   }, [isTabVisible, heartbeatSeq, section.id, checkpoint.id, userId, attemptId]);
   ```

5. Calculate submit button state (use displaySeconds for UX gate):
   ```typescript
   const dwellRequirementMet = displaySeconds >= checkpoint.minimumDwellSeconds;
   const wordRequirementMet = wordCount >= 50;
   const canSubmit = dwellRequirementMet && wordRequirementMet && showCheckpoint;
   ```

6. Add attemptId to form submission (hidden field):
   ```typescript
   <form action={action}>
     <input type="hidden" name="attemptId" value={attemptId} />
     <input type="hidden" name="sectionId" value={section.id} />
     <input type="hidden" name="checkpointId" value={checkpoint.id} />
     {/* ... rest of form */}
   </form>
   ```

7. Add dwell time progress display with reconciliation indicator:
   ```typescript
   <div className="flex items-center gap-2 text-sm">
     <span className={dwellRequirementMet ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       Time: {displaySeconds}s / {checkpoint.minimumDwellSeconds}s {dwellRequirementMet ? "✓" : ""}
     </span>
     {!isTabVisible && (
       <span className="text-amber-600 dark:text-amber-400 text-xs">
         (paused - tab not visible)
       </span>
     )}
   </div>
   ```

8. Requirements checklist + submit button:
   ```typescript
   <div className="mb-4 space-y-2 text-sm">
     <div className={dwellRequirementMet ? "text-green-600 dark:text-green-400" : "text-neutral-500"}>
       {dwellRequirementMet ? "✓" : "○"} Minimum reading time ({checkpoint.minimumDwellSeconds}s)
     </div>
     <div className={wordRequirementMet ? "text-green-600 dark:text-green-400" : "text-neutral-500"}>
       {wordRequirementMet ? "✓" : "○"} Minimum reflection length (50 words)
     </div>
   </div>

   <button
     type="submit"
     disabled={!canSubmit || pending}
     className={`w-full rounded-xl px-6 py-4 font-bold text-white transition-all ${
       canSubmit && !pending
         ? "bg-amber-600 hover:bg-amber-700 cursor-pointer"
         : "bg-neutral-300 dark:bg-neutral-700 cursor-not-allowed opacity-50"
     }`}
   >
     {pending ? "Submitting..." : canSubmit ? "Submit Reflection" : "Complete Requirements to Submit"}
   </button>
   ```

**PRODUCTION-GRADE PROTECTIONS:**
- **Delta-based accumulation:** Server computes delta from `now - lastHeartbeatAt`, clamped to 0-15s
- **Replay prevention:** Monotonic sequence tracking ignores duplicate/old heartbeats
- **attemptId scoping:** Dwell tied to "this reading session", not accumulating across days
- **Rate limiting:** 1 heartbeat per 8-12s, graceful degradation on violation
- **TTL refresh:** Extends session life (1 hour) on each valid heartbeat
- **Server reconciliation:** Client displays server truth every 10s (no drift accumulation)
- **Safari/iOS handling:** pagehide + beforeunload events for cleanup

**WHY this is un-gameable:**
- Cannot replay heartbeats (sequence tracking)
- Cannot fake delta (server computes from timestamps, clamped)
- Cannot accumulate across sessions (attemptId scoping)
- Cannot spam heartbeats (rate limited)
- Cannot submit without heartbeats (server validates attempt existence)
- Cannot modify client timer display (server time is truth for submit validation)
  </action>
  <verify>
CLIENT-SIDE UX:
1. Navigate to guidebook section, wait for checkpoint form
2. Verify timer counts up every second while tab is visible
3. Type 50+ words - submit button still disabled (dwell requirement not met)
4. Wait for dwell time to complete - submit button enables
5. Verify checkmarks appear when requirements met

TAB VISIBILITY & TIMESTAMP-BASED TIMER:
6. Open section, note time at 10s
7. Switch to different tab for 30 seconds
8. Switch back - verify time is still ~10s (paused while hidden, no drift)
9. Verify "(paused - tab not visible)" message appeared while tab was hidden
10. Wait another 10s - verify time is now ~20s (resumed counting)

SERVER-SIDE HEARTBEAT:
11. Open DevTools Network tab
12. Watch for POST requests to heartbeat endpoint every 10 seconds
13. Verify heartbeat only sends while tab is visible (no requests when hidden)
14. Try to submit before server accumulated time met - verify server rejects:
    "Please spend at least X seconds... (You've accumulated Y seconds.)"
15. Wait for server to accumulate enough time, submit - verify success
16. Try direct POST bypassing heartbeats - verify server rejects (no session)

REDIS SESSION:
17. Check Redis for dwell session: `dwell:{userId}:{checkpointId}`
18. Verify `accumulatedSeconds` increments by 10 every heartbeat
19. After successful submit, verify session is cleared from Redis
  </verify>
  <done>
- Timestamp-based timer (performance.now()) avoids drift
- Timer pauses when tab hidden, resumes when visible (uses timestamps not increments)
- "(paused - tab not visible)" message shows/hides correctly
- Heartbeat pings send every 10s while tab is visible
- Server accumulates visibleSeconds in Redis session
- Server validates accumulated time >= minimumDwellSeconds on submit
- Server cannot be bypassed (no heartbeats = no accumulated time = reject)
- Client timer is UX-only, server time is truth
- Redis session cleared after successful submission
- Submit button disabled until BOTH requirements met
- Requirements checklist shows live status with checkmarks
  </done>
</task>

<task type="auto">
  <name>Task 3: Add draft persistence with proper keying and failure-safe behavior</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx</files>
  <action>
Add localStorage persistence with checkpoint-specific keys, debounced saves, and failure-safe behavior:

**DRAFT KEY FORMAT:** `draft:guidebook:{locale}:{sectionSlug}:{checkpointId}`
This prevents drafts from bleeding across sections and ensures uniqueness.

1. Add localStorage key generator:
   ```typescript
   const getDraftKey = (locale: string, sectionId: string, checkpointId: string) => {
     return `draft:guidebook:${locale}:${sectionId}:${checkpointId}`;
   };
   ```

2. Load draft on mount (before first render):
   ```typescript
   const [reflection, setReflection] = useState(() => {
     if (typeof window === "undefined") return "";
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     const saved = localStorage.getItem(draftKey);
     return saved || "";
   });

   // Update initial word count
   const [wordCount, setWordCount] = useState(() => {
     if (typeof window === "undefined") return 0;
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     const saved = localStorage.getItem(draftKey);
     return saved ? countWords(saved) : 0;
   });
   ```

3. Save draft with debouncing (500ms delay to reduce write frequency):
   ```typescript
   useEffect(() => {
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);

     // Debounce: wait 500ms after last change before saving
     const timeoutId = setTimeout(() => {
       if (reflection) {
         localStorage.setItem(draftKey, reflection);
       } else {
         // Clear if empty
         localStorage.removeItem(draftKey);
       }
     }, 500);

     return () => clearTimeout(timeoutId);
   }, [reflection, locale, section.id, checkpoint.id]);
   ```

4. Also save on blur (immediate, no debounce) to ensure data safety:
   ```typescript
   const handleBlur = () => {
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     if (reflection) {
       localStorage.setItem(draftKey, reflection);
     }
   };

   // Add to textarea:
   <textarea
     onBlur={handleBlur}
     // ... existing props
   />
   ```

5. Clear draft ONLY on confirmed successful submission (keep on failure):
   ```typescript
   useEffect(() => {
     // Only clear if submission was successful AND has redirect URL
     if (state.ok && state.redirectTo) {
       const draftKey = getDraftKey(locale, section.id, checkpoint.id);
       localStorage.removeItem(draftKey);
     }
     // If state.ok === false, draft remains intact for retry
   }, [state, locale, section.id, checkpoint.id]);
   ```

6. Display server error if submission failed (preserve draft):
   ```typescript
   {state.message && !state.ok && (
     <div className="mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-900 dark:text-red-100 text-sm">
       {state.message}
     </div>
   )}
   ```

7. Add "Clear Draft" button next to word count:
   ```typescript
   <div className="flex items-center justify-between mt-2">
     <span className={wordCount >= 50 ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       {wordCount} / 50 words {wordCount >= 50 ? "✓" : ""}
     </span>
     {reflection && (
       <button
         type="button"
         onClick={() => {
           const draftKey = getDraftKey(locale, section.id, checkpoint.id);
           setReflection("");
           setWordCount(0);
           localStorage.removeItem(draftKey);
         }}
         className="text-xs text-neutral-500 hover:text-neutral-700 dark:text-neutral-400 dark:hover:text-neutral-200 underline"
       >
         Clear Draft
       </button>
     )}
   </div>
   ```

**POLICY:** Draft persists through refresh, navigation, and failed submissions. Only clears on confirmed success or explicit "Clear Draft" action.

Use window !== "undefined" checks for SSR safety. Do NOT use external debounce libraries - setTimeout is sufficient.
  </action>
  <verify>
BASIC PERSISTENCE:
1. Navigate to guidebook section
2. Type 20 words (slowly, to see debounce working)
3. Wait 500ms - check localStorage in DevTools - verify draft saved with key format `draft:guidebook:en:section-slug:checkpoint-id`
4. Refresh page - verify draft restored in textarea
5. Verify word count reflects restored text (20 / 50 words)

FAILURE-SAFE BEHAVIOR:
6. Type 30 words, wait for dwell time, submit (should fail with <50 words error)
7. Verify server error displays: "Reflection must be at least 50 words..."
8. Verify draft text is STILL in textarea (not cleared on failure)
9. Check localStorage - verify draft still exists
10. Add 20 more words (now 50+), submit - should succeed
11. Verify draft clears ONLY after successful submission

DEBOUNCING & BLUR:
12. Type rapidly without pausing - wait 500ms - verify draft saved
13. Click outside textarea (blur) - verify draft saves immediately (no 500ms wait)

CLEAR DRAFT:
14. Type new draft, click "Clear Draft" button
15. Verify textarea clears, word count resets to 0, localStorage entry removed

CROSS-SECTION ISOLATION:
16. Type draft in Section 1, navigate to Section 2
17. Verify Section 2 textarea is empty (drafts don't bleed across sections)
18. Navigate back to Section 1 - verify original draft restored
  </verify>
  <done>
- Draft key format: `draft:guidebook:{locale}:{sectionId}:{checkpointId}` (prevents bleed)
- Drafts save with 500ms debounce (reduces write frequency)
- Drafts save immediately on textarea blur (data safety)
- Drafts restore correctly on page load with matching word count
- Drafts persist through failed submissions (failure-safe)
- Drafts clear ONLY on confirmed successful submission (state.ok && state.redirectTo)
- Server error messages display without clearing draft
- "Clear Draft" button removes text and localStorage entry
- No SSR/hydration errors (window checks in place)
- No cross-section draft bleeding (checkpoint-specific keys)
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm typecheck` passes with no errors
- [ ] `pnpm build` succeeds without errors
- [ ] Identical countWords function exists in SectionView.tsx and actions.ts
- [ ] Unicode-safe regex `[\p{L}\p{N}]` used in both locations
- [ ] Word count displays "X remaining" and updates in real-time
- [ ] Server rejects submissions <50 words (test with curl bypassing UI)
- [ ] Heartbeat endpoint created and working (pings every 10s)
- [ ] Server accumulates dwell time in Redis session
- [ ] Server rejects submissions without sufficient accumulated time
- [ ] Dwell timer (UX) pauses when tab hidden, resumes when visible
- [ ] No timer drift (uses performance.now() timestamps)
- [ ] Draft persistence with checkpoint-specific keys works
- [ ] Drafts persist through failed submissions, clear only on success
- [ ] No cross-section draft bleeding
- [ ] Submit button disabled until BOTH requirements met
</verification>

<success_criteria>

Phase 1 complete when:

**FORMATION GATE INTEGRITY (no loopholes):**
- Server validates word count (cannot POST <50 words)
- Server validates dwell time via heartbeat accumulation (cannot fake timestamps)
- Word counter matches backend validation (deterministic Unicode-safe algorithm)
- Server does not trust client for dwell time (heartbeat-based, not client-sent)

**UX GATING:**
- Submit disabled until requirements met (client-side UX gate)
- Timer displays live elapsed time with "X remaining" counter
- Tab visibility handled correctly (pauses when hidden, no drift)
- Requirements checklist shows: ✓ 50+ words, ✓ Dwell time met

**DRAFT PERSISTENCE (failure-safe):**
- Drafts restore after refresh with checkpoint-specific keys
- Drafts persist through failed submissions (only clear on success)
- No cross-section draft bleeding

**TECHNICAL:**
- No TypeScript errors, no build errors
- No regression in existing checkpoint flow
- Redis session management working (create, accumulate, clear)
- Heartbeat pings only while tab visible
  </success_criteria>

<output>
After completion, create `.planning/phases/01-checkpoint-submission-enhancement/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Checkpoint Submission Enhancement Summary

**Established formation gate integrity with client + server validation, tab-aware dwell timer, and failure-safe draft persistence**

## Accomplishments

- Implemented Unicode-safe deterministic word count algorithm (identical on client and server)
- Added server-side word count validation (cannot be bypassed via direct POST)
- **Implemented heartbeat-based dwell tracking (server accumulates visible time via 10s pings)**
- **Server validates accumulated dwell time (cannot fake timestamps or bypass)**
- Enhanced client timer with timestamp-based tracking (no drift via performance.now())
- Tab visibility tracking pauses heartbeats and timer when hidden
- Created failure-safe draft persistence (survives failed submissions)
- Built requirements checklist with live status indicators
- Added "X remaining" word count display for better UX
- Implemented checkpoint-specific draft keys (no cross-section bleeding)
- Added debounced saves (500ms) with immediate blur saves
- Redis session management for ephemeral dwell sessions

## Files Created/Modified

- `apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx` - Word count tracking, tab-aware timer, submit gating, draft persistence
- `apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts` - Server-side validation (word count + dwell time)

## Decisions Made

- **Deterministic word count:** Trim, split /\s+/, filter `[\p{L}\p{N}]` (Unicode-safe), count (identical client + server)
- **Heartbeat tracking:** Server accumulates dwell time via 10s pings (cannot be bypassed)
- **Tab visibility policy:** Heartbeats only while tab visible (pauses when hidden)
- **Timestamp-based timer:** Uses `performance.now()` to avoid drift (not interval increments)
- **Draft persistence policy:** Persist through failures, clear only on confirmed success
- **Draft key format:** `draft:guidebook:{locale}:{sectionId}:{checkpointId}` (prevents bleed)
- **Debounce strategy:** 500ms delay + immediate blur save (balance writes vs safety)
- **Redis storage:** Ephemeral dwell sessions (TTL 1 hour, cleared on submit)
- **Server enforcement:** Reject submissions <50 words OR <accumulated dwell time (no loopholes)

## Issues Encountered

[Document any issues encountered during implementation, or "None"]

## Next Phase Readiness

Phase 1 complete. Formation gate is secure (client UX + server enforcement).

Ready for Phase 2: Voice Input & Transcription.

Phase 2 requirements:
- Voice recording UI component with start/stop/pause controls
- OpenAI Whisper API integration for transcription
- Real-time transcription display (editable textarea)
- Audio chunking for long recordings (handle >25MB limit)
- Error handling for transcription failures
- Word count validation must work with transcribed text
</output>
