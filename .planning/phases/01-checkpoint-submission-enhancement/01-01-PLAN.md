---
phase: 01-checkpoint-submission-enhancement
plan: 01
type: execute
---

<objective>
Complete the checkpoint submission flow with word count tracking, enhanced dwell timer UI, and validation enforcement to ensure reflections meet formation requirements before submission.

Purpose: Enforce genuine engagement with formation content by requiring minimum word count (50 words) and dwell time (varies by checkpoint) before allowing submission. This prevents checkbox completion and encourages deeper reflection.

Output: Enhanced checkpoint form with live validation feedback, disabled submit button until requirements met, and draft persistence for recovery.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Existing Code:**
@apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx
@apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts

**Codebase Context:**
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md

**Current Implementation:**
The SectionView.tsx component already has:
- Basic dwell timer (starts on mount, hidden field in form)
- Minimum dwell time check (shows checkpoint after wait)
- Textarea for reflection input
- Server action submission (submitCheckpoint in actions.ts)

**What's Missing:**
- Word count tracker with live display
- 50-word minimum validation (client AND server)
- Submit button disabled until both requirements met
- Visual progress indicators for dwell time and word count
- Draft persistence to localStorage with proper keying
- Clear validation error messages
- Tab visibility handling for dwell timer
- Server-side enforcement of formation gate requirements

**Requirements from PROJECT.md:**
- Word count tracker (minimum 50 words enforced)
- Dwell timer (varies by checkpoint, enforced client + server)
- Submit button disabled until requirements met
- Clean validation messages

**Formation Gate Integrity:**
This phase establishes the validation layer that all subsequent phases depend on. Both client-side (UX) and server-side (security) enforcement are required to prevent loopholes. The word count algorithm must be deterministic and match exactly between client and server.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add word count validation (client + server)</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx, apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts</files>
  <action>
Add deterministic word count validation on both client (UX) and server (security):

**DETERMINISTIC WORD COUNT ALGORITHM** (use exactly this on both client and server):
```typescript
function countWords(text: string): number {
  // Normalize: trim leading/trailing whitespace
  const normalized = text.trim();

  // Handle empty string
  if (normalized.length === 0) return 0;

  // Split on any whitespace (space, tab, newline)
  const tokens = normalized.split(/\s+/);

  // Filter out empty tokens and punctuation-only tokens
  const words = tokens.filter(token => {
    return token.length > 0 && /\w/.test(token); // Must contain at least one word character
  });

  return words.length;
}
```

**CLIENT-SIDE (SectionView.tsx):**

1. Add the canonical countWords function at top of component (outside component function for clarity)

2. Add state for reflection text and word count:
   ```typescript
   const [reflection, setReflection] = useState("");
   const [wordCount, setWordCount] = useState(0);
   ```

3. Handle textarea changes:
   ```typescript
   const handleReflectionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
     const text = e.target.value;
     setReflection(text);
     setWordCount(countWords(text));
   };
   ```

4. Add word count display showing REMAINING words (better UX):
   ```typescript
   <div className="flex items-center justify-between mt-2 text-sm">
     <span className={wordCount >= 50 ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       {wordCount} / 50 words {wordCount >= 50 ? "✓" : ""}
     </span>
     {wordCount < 50 && (
       <span className="text-amber-600 dark:text-amber-400">
         {50 - wordCount} remaining
       </span>
     )}
   </div>
   ```

5. Update textarea to controlled component:
   ```typescript
   <textarea
     value={reflection}
     onChange={handleReflectionChange}
     // ... existing props
   />
   ```

**SERVER-SIDE (actions.ts):**

1. Add the SAME canonical countWords function to actions.ts (duplicate is intentional for security)

2. In submitCheckpoint server action, BEFORE processing the reflection:
   ```typescript
   // Validate word count (server-side enforcement)
   const wordCount = countWords(formData.get('reflection') as string);
   if (wordCount < 50) {
     return {
       ok: false,
       message: `Reflection must be at least 50 words (you submitted ${wordCount} words).`
     };
   }
   ```

3. Validate dwell time (server-side enforcement):
   ```typescript
   const dwellTimeSeconds = parseInt(formData.get('dwellTimeSeconds') as string);
   const minimumDwellSeconds = parseInt(formData.get('minimumDwellSeconds') as string);

   if (dwellTimeSeconds < minimumDwellSeconds) {
     return {
       ok: false,
       message: `Please spend at least ${minimumDwellSeconds} seconds engaging with the content.`
     };
   }
   ```

4. Add hidden field to form for minimum dwell time:
   ```typescript
   <input type="hidden" name="minimumDwellSeconds" value={checkpoint.minimumDwellSeconds} />
   ```

**WHY DUPLICATE THE FUNCTION:** Server-side validation cannot be bypassed by modifying client code or POSTing directly. Client and server must use identical logic to avoid mismatch errors.

**NOTE:** SectionView.tsx already has "use client" directive - no changes needed there.
  </action>
  <verify>
CLIENT-SIDE:
1. Navigate to any guidebook section
2. Type in textarea and verify word count updates live
3. Verify "X remaining" shows correctly (e.g., "12 / 50 words (38 remaining)")
4. Type exactly 50 words - verify checkmark appears
5. Verify color changes neutral → green at 50+ words

SERVER-SIDE:
6. Open browser DevTools Network tab
7. Type 30 words, wait for dwell time, submit
8. Verify server returns error: "Reflection must be at least 50 words (you submitted 30 words)"
9. Type 50+ words, submit - verify success
10. Test direct POST with curl (bypassing UI) - verify server rejects <50 words:
    ```bash
    curl -X POST /guidebook/awakening/covenant-introduction \
      -d "reflection=short text" \
      -d "dwellTimeSeconds=120"
    ```
  </verify>
  <done>
- Identical countWords function exists in both SectionView.tsx and actions.ts
- Client-side word count updates in real-time with "X remaining" display
- Server-side validation rejects submissions < 50 words with clear error message
- Server-side validation rejects submissions < minimum dwell time
- Color feedback and checkmark work correctly
- Hidden fields pass minimumDwellSeconds to server for validation
- Server cannot be bypassed by direct POST or modified client code
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance dwell timer with tab visibility and submit button gating</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx</files>
  <action>
Enhance dwell timer with tab visibility handling and submit button validation:

**POLICY DECISION:** Dwell time counts only while tab is VISIBLE (document.visibilityState === 'visible'). This prevents gaming by opening section in background tab and walking away.

1. Add state for elapsed time and tab visibility:
   ```typescript
   const [elapsedSeconds, setElapsedSeconds] = useState(0);
   const [isTabVisible, setIsTabVisible] = useState(true);
   ```

2. Track tab visibility changes:
   ```typescript
   useEffect(() => {
     const handleVisibilityChange = () => {
       setIsTabVisible(document.visibilityState === 'visible');
     };

     document.addEventListener('visibilitychange', handleVisibilityChange);
     return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
   }, []);
   ```

3. Add interval to track elapsed time (only when tab visible):
   ```typescript
   useEffect(() => {
     let lastUpdateTime = Date.now();

     const interval = setInterval(() => {
       if (isTabVisible) {
         const now = Date.now();
         const secondsSinceLastUpdate = Math.floor((now - lastUpdateTime) / 1000);

         if (secondsSinceLastUpdate >= 1) {
           setElapsedSeconds(prev => prev + secondsSinceLastUpdate);
           lastUpdateTime = now;
         }
       }
     }, 1000);

     return () => clearInterval(interval);
   }, [isTabVisible]);
   ```

4. Calculate if requirements are met (source minimumDwellSeconds from checkpoint object):
   ```typescript
   const dwellRequirementMet = elapsedSeconds >= checkpoint.minimumDwellSeconds;
   const wordRequirementMet = wordCount >= 50;
   const canSubmit = dwellRequirementMet && wordRequirementMet && showCheckpoint;
   ```

5. Add dwell time progress display:
   ```typescript
   <div className="flex items-center gap-2 text-sm">
     <span className={dwellRequirementMet ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       Time: {elapsedSeconds}s / {checkpoint.minimumDwellSeconds}s {dwellRequirementMet ? "✓" : ""}
     </span>
     {!isTabVisible && (
       <span className="text-amber-600 dark:text-amber-400 text-xs">
         (paused - tab not visible)
       </span>
     )}
   </div>
   ```

6. Update submit button with disabled state and clear visual feedback:
   ```typescript
   <button
     type="submit"
     disabled={!canSubmit || pending}
     className={`w-full rounded-xl px-6 py-4 font-bold text-white transition-all ${
       canSubmit && !pending
         ? "bg-amber-600 hover:bg-amber-700 cursor-pointer"
         : "bg-neutral-300 dark:bg-neutral-700 cursor-not-allowed opacity-50"
     }`}
   >
     {pending ? "Submitting..." : canSubmit ? "Submit Reflection" : "Complete Requirements to Submit"}
   </button>
   ```

7. Add requirements checklist above submit button:
   ```typescript
   <div className="mb-4 space-y-2 text-sm">
     <div className={dwellRequirementMet ? "text-green-600 dark:text-green-400" : "text-neutral-500"}>
       {dwellRequirementMet ? "✓" : "○"} Minimum reading time ({checkpoint.minimumDwellSeconds}s)
     </div>
     <div className={wordRequirementMet ? "text-green-600 dark:text-green-400" : "text-neutral-500"}>
       {wordRequirementMet ? "✓" : "○"} Minimum reflection length (50 words)
     </div>
   </div>
   ```

**IMPORTANT:** Keep the existing minimumWaitMs timer that controls showCheckpoint - do NOT remove it. This task ADDS visible-only dwell tracking and UI feedback.

**NOTE:** minimumDwellSeconds is already sourced from checkpoint object (checkpoint.minimumDwellSeconds) - no hardcoding needed.
  </action>
  <verify>
BASIC FLOW:
1. Navigate to guidebook section, wait for checkpoint form
2. Type less than 50 words - submit button disabled (word requirement not met)
3. Verify dwell timer counts up every second
4. Type 50+ words before dwell time met - submit button still disabled (dwell requirement not met)
5. Wait for dwell time to complete - submit button enables
6. Verify checkmarks appear when requirements met
7. Verify button visual state (color, cursor, opacity) changes correctly

TAB VISIBILITY:
8. Open section in new tab
9. Note elapsed time (e.g., 10s)
10. Switch to different tab for 30 seconds
11. Switch back - verify elapsed time is still ~10s (paused while hidden)
12. Verify "(paused - tab not visible)" message appeared while tab was hidden
13. Verify timer resumes counting when tab becomes visible again
  </verify>
  <done>
- Dwell timer shows elapsed time with live second-by-second updates
- Timer pauses when tab is hidden (document.visibilityState !== 'visible')
- Timer resumes when tab becomes visible again
- "(paused - tab not visible)" message shows/hides correctly
- Submit button disabled until BOTH requirements met (word count AND dwell time)
- Requirements checklist shows live status with checkmarks (✓ when met, ○ when not)
- Button visual state (color, cursor, opacity) reflects canSubmit accurately
- Pending state shows "Submitting..." during form submission
- minimumDwellSeconds sourced from checkpoint object (no hardcoding)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add draft persistence with proper keying and failure-safe behavior</name>
  <files>apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx</files>
  <action>
Add localStorage persistence with checkpoint-specific keys, debounced saves, and failure-safe behavior:

**DRAFT KEY FORMAT:** `draft:guidebook:{locale}:{sectionSlug}:{checkpointId}`
This prevents drafts from bleeding across sections and ensures uniqueness.

1. Add localStorage key generator:
   ```typescript
   const getDraftKey = (locale: string, sectionId: string, checkpointId: string) => {
     return `draft:guidebook:${locale}:${sectionId}:${checkpointId}`;
   };
   ```

2. Load draft on mount (before first render):
   ```typescript
   const [reflection, setReflection] = useState(() => {
     if (typeof window === "undefined") return "";
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     const saved = localStorage.getItem(draftKey);
     return saved || "";
   });

   // Update initial word count
   const [wordCount, setWordCount] = useState(() => {
     if (typeof window === "undefined") return 0;
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     const saved = localStorage.getItem(draftKey);
     return saved ? countWords(saved) : 0;
   });
   ```

3. Save draft with debouncing (500ms delay to reduce write frequency):
   ```typescript
   useEffect(() => {
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);

     // Debounce: wait 500ms after last change before saving
     const timeoutId = setTimeout(() => {
       if (reflection) {
         localStorage.setItem(draftKey, reflection);
       } else {
         // Clear if empty
         localStorage.removeItem(draftKey);
       }
     }, 500);

     return () => clearTimeout(timeoutId);
   }, [reflection, locale, section.id, checkpoint.id]);
   ```

4. Also save on blur (immediate, no debounce) to ensure data safety:
   ```typescript
   const handleBlur = () => {
     const draftKey = getDraftKey(locale, section.id, checkpoint.id);
     if (reflection) {
       localStorage.setItem(draftKey, reflection);
     }
   };

   // Add to textarea:
   <textarea
     onBlur={handleBlur}
     // ... existing props
   />
   ```

5. Clear draft ONLY on confirmed successful submission (keep on failure):
   ```typescript
   useEffect(() => {
     // Only clear if submission was successful AND has redirect URL
     if (state.ok && state.redirectTo) {
       const draftKey = getDraftKey(locale, section.id, checkpoint.id);
       localStorage.removeItem(draftKey);
     }
     // If state.ok === false, draft remains intact for retry
   }, [state, locale, section.id, checkpoint.id]);
   ```

6. Display server error if submission failed (preserve draft):
   ```typescript
   {state.message && !state.ok && (
     <div className="mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-900 dark:text-red-100 text-sm">
       {state.message}
     </div>
   )}
   ```

7. Add "Clear Draft" button next to word count:
   ```typescript
   <div className="flex items-center justify-between mt-2">
     <span className={wordCount >= 50 ? "text-green-600 dark:text-green-400 font-medium" : "text-neutral-600 dark:text-neutral-400"}>
       {wordCount} / 50 words {wordCount >= 50 ? "✓" : ""}
     </span>
     {reflection && (
       <button
         type="button"
         onClick={() => {
           const draftKey = getDraftKey(locale, section.id, checkpoint.id);
           setReflection("");
           setWordCount(0);
           localStorage.removeItem(draftKey);
         }}
         className="text-xs text-neutral-500 hover:text-neutral-700 dark:text-neutral-400 dark:hover:text-neutral-200 underline"
       >
         Clear Draft
       </button>
     )}
   </div>
   ```

**POLICY:** Draft persists through refresh, navigation, and failed submissions. Only clears on confirmed success or explicit "Clear Draft" action.

Use window !== "undefined" checks for SSR safety. Do NOT use external debounce libraries - setTimeout is sufficient.
  </action>
  <verify>
BASIC PERSISTENCE:
1. Navigate to guidebook section
2. Type 20 words (slowly, to see debounce working)
3. Wait 500ms - check localStorage in DevTools - verify draft saved with key format `draft:guidebook:en:section-slug:checkpoint-id`
4. Refresh page - verify draft restored in textarea
5. Verify word count reflects restored text (20 / 50 words)

FAILURE-SAFE BEHAVIOR:
6. Type 30 words, wait for dwell time, submit (should fail with <50 words error)
7. Verify server error displays: "Reflection must be at least 50 words..."
8. Verify draft text is STILL in textarea (not cleared on failure)
9. Check localStorage - verify draft still exists
10. Add 20 more words (now 50+), submit - should succeed
11. Verify draft clears ONLY after successful submission

DEBOUNCING & BLUR:
12. Type rapidly without pausing - wait 500ms - verify draft saved
13. Click outside textarea (blur) - verify draft saves immediately (no 500ms wait)

CLEAR DRAFT:
14. Type new draft, click "Clear Draft" button
15. Verify textarea clears, word count resets to 0, localStorage entry removed

CROSS-SECTION ISOLATION:
16. Type draft in Section 1, navigate to Section 2
17. Verify Section 2 textarea is empty (drafts don't bleed across sections)
18. Navigate back to Section 1 - verify original draft restored
  </verify>
  <done>
- Draft key format: `draft:guidebook:{locale}:{sectionId}:{checkpointId}` (prevents bleed)
- Drafts save with 500ms debounce (reduces write frequency)
- Drafts save immediately on textarea blur (data safety)
- Drafts restore correctly on page load with matching word count
- Drafts persist through failed submissions (failure-safe)
- Drafts clear ONLY on confirmed successful submission (state.ok && state.redirectTo)
- Server error messages display without clearing draft
- "Clear Draft" button removes text and localStorage entry
- No SSR/hydration errors (window checks in place)
- No cross-section draft bleeding (checkpoint-specific keys)
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm typecheck` passes with no errors
- [ ] `pnpm build` succeeds without errors
- [ ] Submit button disabled until BOTH requirements met (client-side)
- [ ] Server rejects submissions that don't meet requirements (test with curl)
- [ ] Identical countWords function exists in SectionView.tsx and actions.ts
- [ ] Word count displays "X remaining" and updates in real-time
- [ ] Dwell timer pauses when tab is hidden, resumes when visible
- [ ] Draft persistence works across page refresh with checkpoint-specific keys
- [ ] Drafts persist through failed submissions, clear only on success
- [ ] No cross-section draft bleeding
</verification>

<success_criteria>

Phase 1 complete when:
- Submit is disabled until requirements met (client UX gating)
- Server validates word count and dwell time (cannot be bypassed)
- Word counter matches backend validation (deterministic algorithm)
- Draft restores after refresh and clears after successful submit
- Failed submit never loses user text (failure-safe)
- Timer displays live elapsed time + required threshold
- Tab visibility handled correctly (pauses when hidden)
- Requirements checklist shows: ✓ 50+ words, ✓ Dwell time met
- No TypeScript errors, no build errors
- No regression in existing checkpoint flow
  </success_criteria>

<output>
After completion, create `.planning/phases/01-checkpoint-submission-enhancement/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Checkpoint Submission Enhancement Summary

**Established formation gate integrity with client + server validation, tab-aware dwell timer, and failure-safe draft persistence**

## Accomplishments

- Implemented deterministic word count algorithm (identical on client and server)
- Added server-side validation enforcement (cannot be bypassed)
- Enhanced dwell timer with tab visibility tracking (pauses when hidden)
- Created failure-safe draft persistence (survives failed submissions)
- Built requirements checklist with live status indicators
- Added "X remaining" word count display for better UX
- Implemented checkpoint-specific draft keys (no cross-section bleeding)
- Added debounced saves (500ms) with immediate blur saves

## Files Created/Modified

- `apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/SectionView.tsx` - Word count tracking, tab-aware timer, submit gating, draft persistence
- `apps/ruach-next/src/app/[locale]/guidebook/awakening/[slug]/actions.ts` - Server-side validation (word count + dwell time)

## Decisions Made

- **Deterministic word count:** Trim, split /\s+/, filter /\w/, count (identical client + server)
- **Tab visibility policy:** Dwell counts only while tab visible (prevents gaming)
- **Draft persistence policy:** Persist through failures, clear only on confirmed success
- **Draft key format:** `draft:guidebook:{locale}:{sectionId}:{checkpointId}` (prevents bleed)
- **Debounce strategy:** 500ms delay + immediate blur save (balance writes vs safety)
- **Server enforcement:** Reject submissions <50 words or <minimumDwellSeconds

## Issues Encountered

[Document any issues encountered during implementation, or "None"]

## Next Phase Readiness

Phase 1 complete. Formation gate is secure (client UX + server enforcement).

Ready for Phase 2: Voice Input & Transcription.

Phase 2 requirements:
- Voice recording UI component with start/stop/pause controls
- OpenAI Whisper API integration for transcription
- Real-time transcription display (editable textarea)
- Audio chunking for long recordings (handle >25MB limit)
- Error handling for transcription failures
- Word count validation must work with transcribed text
</output>
