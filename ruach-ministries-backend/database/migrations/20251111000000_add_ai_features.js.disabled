/**
 * Phase 4: AI Features Migration
 *
 * Adds support for:
 * - Content embeddings for semantic search
 * - AI conversation history
 * - User content interactions for recommendations
 * - Transcription job tracking
 */

module.exports = {
  /**
   * Run migrations
   */
  async up(knex) {
    console.log('ðŸ“¦ Phase 4: Adding AI features tables...');

    // Check if we're using PostgreSQL (for vector support)
    const isPostgres = knex.client.config.client === 'postgres';

    if (isPostgres) {
      // Enable pgvector extension (PostgreSQL only)
      await knex.raw('CREATE EXTENSION IF NOT EXISTS vector');
      console.log('âœ… pgvector extension enabled');
    }

    // 1. Content Embeddings Table
    // Stores vector embeddings for semantic search
    await knex.schema.createTable('content_embeddings', (table) => {
      table.increments('id').primary();
      table.string('content_type', 50).notNullable(); // 'media', 'lesson', 'blog', 'course', 'series'
      table.integer('content_id').notNullable();
      table.text('text_content').notNullable(); // What was embedded
      table.json('metadata'); // {title, description, tags, speakers, etc.}
      table.timestamps(true, true);

      // Composite unique constraint
      table.unique(['content_type', 'content_id']);

      // Indexes
      table.index('content_type');
      table.index(['content_type', 'content_id']);
    });
    console.log('âœ… Created content_embeddings table');

    // Add embedding column separately (PostgreSQL uses vector type, SQLite uses TEXT)
    if (isPostgres) {
      await knex.raw('ALTER TABLE content_embeddings ADD COLUMN embedding vector(1536)');
      // Create vector similarity index
      await knex.raw(
        'CREATE INDEX content_embeddings_vector_idx ON content_embeddings USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100)'
      );
      console.log('âœ… Added pgvector embedding column and index');
    } else {
      // SQLite: store as JSON text (for development only)
      await knex.schema.alterTable('content_embeddings', (table) => {
        table.text('embedding'); // JSON array
      });
      console.log('âš ï¸  Using JSON text for embeddings (SQLite - dev only)');
    }

    // 2. AI Conversations Table
    // Stores conversation sessions with the AI assistant
    // Check if up_users table exists before adding foreign key
    const hasUpUsers = await knex.schema.hasTable('up_users');

    await knex.schema.createTable('ai_conversations', (table) => {
      table.increments('id').primary();
      if (hasUpUsers) {
        table.integer('user_id').references('id').inTable('up_users').onDelete('CASCADE');
      } else {
        table.integer('user_id').nullable();
        console.warn('âš ï¸  up_users table not found - creating user_id without foreign key');
      }
      table.text('title'); // Auto-generated from first message
      table.timestamps(true, true);

      table.index('user_id');
      table.index('created_at');
    });
    console.log('âœ… Created ai_conversations table');

    // 3. AI Messages Table
    // Stores individual messages in conversations
    await knex.schema.createTable('ai_messages', (table) => {
      table.increments('id').primary();
      table.integer('conversation_id').references('id').inTable('ai_conversations').onDelete('CASCADE');
      table.string('role', 20).notNullable(); // 'user' | 'assistant' | 'system'
      table.text('content').notNullable();
      table.json('metadata'); // {model, tokens, sources, etc.}
      table.timestamp('created_at').defaultTo(knex.fn.now());

      table.index('conversation_id');
      table.index('created_at');
    });
    console.log('âœ… Created ai_messages table');

    // 4. User Interactions Table
    // Tracks user behavior for recommendations
    await knex.schema.createTable('user_interactions', (table) => {
      table.increments('id').primary();
      if (hasUpUsers) {
        table.integer('user_id').references('id').inTable('up_users').onDelete('CASCADE');
      } else {
        table.integer('user_id').nullable();
      }
      table.string('content_type', 50).notNullable();
      table.integer('content_id').notNullable();
      table.string('interaction_type', 20).notNullable(); // 'view', 'complete', 'like', 'bookmark'
      table.integer('duration_sec'); // For videos
      table.boolean('completed').defaultTo(false);
      table.timestamp('created_at').defaultTo(knex.fn.now());

      table.index(['user_id', 'created_at']);
      table.index(['content_type', 'content_id']);
      table.index('interaction_type');
    });
    console.log('âœ… Created user_interactions table');

    // 5. Transcription Jobs Table
    // Tracks automated transcription jobs
    await knex.schema.createTable('transcription_jobs', (table) => {
      table.increments('id').primary();
      table.string('content_type', 50).notNullable(); // 'media' | 'lesson'
      table.integer('content_id').notNullable();
      table.text('video_url').notNullable();
      table.string('status', 20).defaultTo('pending'); // pending, processing, completed, failed
      table.integer('progress').defaultTo(0); // 0-100
      table.text('error_message');
      table.text('transcript'); // Final result
      table.json('metadata'); // {duration, language, cost, etc.}
      table.timestamp('created_at').defaultTo(knex.fn.now());
      table.timestamp('updated_at').defaultTo(knex.fn.now());
      table.timestamp('completed_at');

      table.index('status');
      table.index(['content_type', 'content_id']);
      table.index('created_at');
    });
    console.log('âœ… Created transcription_jobs table');

    console.log('ðŸŽ‰ Phase 4 migration completed successfully!');
  },

  /**
   * Rollback migrations
   */
  async down(knex) {
    console.log('ðŸ”„ Rolling back Phase 4 AI features...');

    await knex.schema.dropTableIfExists('transcription_jobs');
    await knex.schema.dropTableIfExists('user_interactions');
    await knex.schema.dropTableIfExists('ai_messages');
    await knex.schema.dropTableIfExists('ai_conversations');
    await knex.schema.dropTableIfExists('content_embeddings');

    const isPostgres = knex.client.config.client === 'postgres';
    if (isPostgres) {
      await knex.raw('DROP EXTENSION IF EXISTS vector CASCADE');
    }

    console.log('âœ… Rollback completed');
  },
};
